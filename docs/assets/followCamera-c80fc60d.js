import{n as t,p as i,j as m,K as w,F as O,P as x,b8 as P,H,U as R,V as g,N as v,v as M,ax as S}from"./runBabylonPlaygroundScene-32a4afbd.js";class r{constructor(){this.keysHeightOffsetIncr=[38],this.keysHeightOffsetDecr=[40],this.keysHeightOffsetModifierAlt=!1,this.keysHeightOffsetModifierCtrl=!1,this.keysHeightOffsetModifierShift=!1,this.keysRotationOffsetIncr=[37],this.keysRotationOffsetDecr=[39],this.keysRotationOffsetModifierAlt=!1,this.keysRotationOffsetModifierCtrl=!1,this.keysRotationOffsetModifierShift=!1,this.keysRadiusIncr=[40],this.keysRadiusDecr=[38],this.keysRadiusModifierAlt=!0,this.keysRadiusModifierCtrl=!1,this.keysRadiusModifierShift=!1,this.heightSensibility=1,this.rotationSensibility=1,this.radiusSensibility=1,this._keys=new Array}attachControl(s){s=m.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(a=>{const e=a.event;if(!e.metaKey){if(a.type===w.KEYDOWN)this._ctrlPressed=e.ctrlKey,this._altPressed=e.altKey,this._shiftPressed=e.shiftKey,(this.keysHeightOffsetIncr.indexOf(e.keyCode)!==-1||this.keysHeightOffsetDecr.indexOf(e.keyCode)!==-1||this.keysRotationOffsetIncr.indexOf(e.keyCode)!==-1||this.keysRotationOffsetDecr.indexOf(e.keyCode)!==-1||this.keysRadiusIncr.indexOf(e.keyCode)!==-1||this.keysRadiusDecr.indexOf(e.keyCode)!==-1)&&(this._keys.indexOf(e.keyCode)===-1&&this._keys.push(e.keyCode),e.preventDefault&&(s||e.preventDefault()));else if(this.keysHeightOffsetIncr.indexOf(e.keyCode)!==-1||this.keysHeightOffsetDecr.indexOf(e.keyCode)!==-1||this.keysRotationOffsetIncr.indexOf(e.keyCode)!==-1||this.keysRotationOffsetDecr.indexOf(e.keyCode)!==-1||this.keysRadiusIncr.indexOf(e.keyCode)!==-1||this.keysRadiusDecr.indexOf(e.keyCode)!==-1){const o=this._keys.indexOf(e.keyCode);o>=0&&this._keys.splice(o,1),e.preventDefault&&(s||e.preventDefault())}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){this._onKeyboardObserver&&this._keys.forEach(s=>{this.keysHeightOffsetIncr.indexOf(s)!==-1&&this._modifierHeightOffset()?this.camera.heightOffset+=this.heightSensibility:this.keysHeightOffsetDecr.indexOf(s)!==-1&&this._modifierHeightOffset()?this.camera.heightOffset-=this.heightSensibility:this.keysRotationOffsetIncr.indexOf(s)!==-1&&this._modifierRotationOffset()?(this.camera.rotationOffset+=this.rotationSensibility,this.camera.rotationOffset%=360):this.keysRotationOffsetDecr.indexOf(s)!==-1&&this._modifierRotationOffset()?(this.camera.rotationOffset-=this.rotationSensibility,this.camera.rotationOffset%=360):this.keysRadiusIncr.indexOf(s)!==-1&&this._modifierRadius()?this.camera.radius+=this.radiusSensibility:this.keysRadiusDecr.indexOf(s)!==-1&&this._modifierRadius()&&(this.camera.radius-=this.radiusSensibility)})}getClassName(){return"FollowCameraKeyboardMoveInput"}getSimpleName(){return"keyboard"}_modifierHeightOffset(){return this.keysHeightOffsetModifierAlt===this._altPressed&&this.keysHeightOffsetModifierCtrl===this._ctrlPressed&&this.keysHeightOffsetModifierShift===this._shiftPressed}_modifierRotationOffset(){return this.keysRotationOffsetModifierAlt===this._altPressed&&this.keysRotationOffsetModifierCtrl===this._ctrlPressed&&this.keysRotationOffsetModifierShift===this._shiftPressed}_modifierRadius(){return this.keysRadiusModifierAlt===this._altPressed&&this.keysRadiusModifierCtrl===this._ctrlPressed&&this.keysRadiusModifierShift===this._shiftPressed}}t([i()],r.prototype,"keysHeightOffsetIncr",void 0);t([i()],r.prototype,"keysHeightOffsetDecr",void 0);t([i()],r.prototype,"keysHeightOffsetModifierAlt",void 0);t([i()],r.prototype,"keysHeightOffsetModifierCtrl",void 0);t([i()],r.prototype,"keysHeightOffsetModifierShift",void 0);t([i()],r.prototype,"keysRotationOffsetIncr",void 0);t([i()],r.prototype,"keysRotationOffsetDecr",void 0);t([i()],r.prototype,"keysRotationOffsetModifierAlt",void 0);t([i()],r.prototype,"keysRotationOffsetModifierCtrl",void 0);t([i()],r.prototype,"keysRotationOffsetModifierShift",void 0);t([i()],r.prototype,"keysRadiusIncr",void 0);t([i()],r.prototype,"keysRadiusDecr",void 0);t([i()],r.prototype,"keysRadiusModifierAlt",void 0);t([i()],r.prototype,"keysRadiusModifierCtrl",void 0);t([i()],r.prototype,"keysRadiusModifierShift",void 0);t([i()],r.prototype,"heightSensibility",void 0);t([i()],r.prototype,"rotationSensibility",void 0);t([i()],r.prototype,"radiusSensibility",void 0);O.FollowCameraKeyboardMoveInput=r;class u{constructor(){this.axisControlRadius=!0,this.axisControlHeight=!1,this.axisControlRotation=!1,this.wheelPrecision=3,this.wheelDeltaPercentage=0}attachControl(s){s=m.BackCompatCameraNoPreventDefault(arguments),this._wheel=a=>{if(a.type!==x.POINTERWHEEL)return;const e=a.event;let o=0;const h=Math.max(-1,Math.min(1,e.deltaY));this.wheelDeltaPercentage?(console.assert(this.axisControlRadius+this.axisControlHeight+this.axisControlRotation<=1,"wheelDeltaPercentage only usable when mouse wheel controls ONE axis. Currently enabled: axisControlRadius: "+this.axisControlRadius+", axisControlHeightOffset: "+this.axisControlHeight+", axisControlRotationOffset: "+this.axisControlRotation),this.axisControlRadius?o=h*.01*this.wheelDeltaPercentage*this.camera.radius:this.axisControlHeight?o=h*.01*this.wheelDeltaPercentage*this.camera.heightOffset:this.axisControlRotation&&(o=h*.01*this.wheelDeltaPercentage*this.camera.rotationOffset)):o=h*this.wheelPrecision,o&&(this.axisControlRadius?this.camera.radius+=o:this.axisControlHeight?this.camera.heightOffset-=o:this.axisControlRotation&&(this.camera.rotationOffset-=o)),e.preventDefault&&(s||e.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,x.POINTERWHEEL)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null)}getClassName(){return"ArcRotateCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}}t([i()],u.prototype,"axisControlRadius",void 0);t([i()],u.prototype,"axisControlHeight",void 0);t([i()],u.prototype,"axisControlRotation",void 0);t([i()],u.prototype,"wheelPrecision",void 0);t([i()],u.prototype,"wheelDeltaPercentage",void 0);O.FollowCameraMouseWheelInput=u;class n extends P{constructor(){super(...arguments),this.angularSensibilityX=1,this.angularSensibilityY=1,this.pinchPrecision=1e4,this.pinchDeltaPercentage=0,this.axisXControlRadius=!1,this.axisXControlHeight=!1,this.axisXControlRotation=!0,this.axisYControlRadius=!1,this.axisYControlHeight=!0,this.axisYControlRotation=!1,this.axisPinchControlRadius=!0,this.axisPinchControlHeight=!1,this.axisPinchControlRotation=!1,this.warningEnable=!0,this._warningCounter=0}getClassName(){return"FollowCameraPointersInput"}onTouch(s,a,e){this._warning(),this.axisXControlRotation?this.camera.rotationOffset+=a/this.angularSensibilityX:this.axisYControlRotation&&(this.camera.rotationOffset+=e/this.angularSensibilityX),this.axisXControlHeight?this.camera.heightOffset+=a/this.angularSensibilityY:this.axisYControlHeight&&(this.camera.heightOffset+=e/this.angularSensibilityY),this.axisXControlRadius?this.camera.radius-=a/this.angularSensibilityY:this.axisYControlRadius&&(this.camera.radius-=e/this.angularSensibilityY)}onMultiTouch(s,a,e,o,h,c){if(e===0&&h===null||o===0&&c===null)return;let d=(o-e)/(this.pinchPrecision*(this.angularSensibilityX+this.angularSensibilityY)/2);this.pinchDeltaPercentage?(d*=.01*this.pinchDeltaPercentage,this.axisPinchControlRotation&&(this.camera.rotationOffset+=d*this.camera.rotationOffset),this.axisPinchControlHeight&&(this.camera.heightOffset+=d*this.camera.heightOffset),this.axisPinchControlRadius&&(this.camera.radius-=d*this.camera.radius)):(this.axisPinchControlRotation&&(this.camera.rotationOffset+=d),this.axisPinchControlHeight&&(this.camera.heightOffset+=d),this.axisPinchControlRadius&&(this.camera.radius-=d))}_warning(){if(!this.warningEnable||this._warningCounter++%100!==0)return;const s="It probably only makes sense to control ONE camera property with each pointer axis. Set 'warningEnable = false' if you are sure. Currently enabled: ";console.assert(this.axisXControlRotation+this.axisXControlHeight+this.axisXControlRadius<=1,s+"axisXControlRotation: "+this.axisXControlRotation+", axisXControlHeight: "+this.axisXControlHeight+", axisXControlRadius: "+this.axisXControlRadius),console.assert(this.axisYControlRotation+this.axisYControlHeight+this.axisYControlRadius<=1,s+"axisYControlRotation: "+this.axisYControlRotation+", axisYControlHeight: "+this.axisYControlHeight+", axisYControlRadius: "+this.axisYControlRadius),console.assert(this.axisPinchControlRotation+this.axisPinchControlHeight+this.axisPinchControlRadius<=1,s+"axisPinchControlRotation: "+this.axisPinchControlRotation+", axisPinchControlHeight: "+this.axisPinchControlHeight+", axisPinchControlRadius: "+this.axisPinchControlRadius)}}t([i()],n.prototype,"angularSensibilityX",void 0);t([i()],n.prototype,"angularSensibilityY",void 0);t([i()],n.prototype,"pinchPrecision",void 0);t([i()],n.prototype,"pinchDeltaPercentage",void 0);t([i()],n.prototype,"axisXControlRadius",void 0);t([i()],n.prototype,"axisXControlHeight",void 0);t([i()],n.prototype,"axisXControlRotation",void 0);t([i()],n.prototype,"axisYControlRadius",void 0);t([i()],n.prototype,"axisYControlHeight",void 0);t([i()],n.prototype,"axisYControlRotation",void 0);t([i()],n.prototype,"axisPinchControlRadius",void 0);t([i()],n.prototype,"axisPinchControlHeight",void 0);t([i()],n.prototype,"axisPinchControlRotation",void 0);O.FollowCameraPointersInput=n;class I extends H{constructor(s){super(s)}addKeyboard(){return this.add(new r),this}addMouseWheel(){return this.add(new u),this}addPointers(){return this.add(new n),this}addVRDeviceOrientation(){return console.warn("DeviceOrientation support not yet implemented for FollowCamera."),this}}R.AddNodeConstructor("FollowCamera",(f,s)=>()=>new l(f,g.Zero(),s));R.AddNodeConstructor("ArcFollowCamera",(f,s)=>()=>new D(f,0,0,1,null,s));class l extends v{constructor(s,a,e,o=null){super(s,a,e),this.radius=12,this.lowerRadiusLimit=null,this.upperRadiusLimit=null,this.rotationOffset=0,this.lowerRotationOffsetLimit=null,this.upperRotationOffsetLimit=null,this.heightOffset=4,this.lowerHeightOffsetLimit=null,this.upperHeightOffsetLimit=null,this.cameraAcceleration=.05,this.maxCameraSpeed=20,this.lockedTarget=o,this.inputs=new I(this),this.inputs.addKeyboard().addMouseWheel().addPointers()}_follow(s){if(!s)return;const a=M.Matrix[0];s.absoluteRotationQuaternion.toRotationMatrix(a);const e=Math.atan2(a.m[8],a.m[10]),o=m.ToRadians(this.rotationOffset)+e,h=s.getAbsolutePosition(),c=h.x+Math.sin(o)*this.radius,d=h.z+Math.cos(o)*this.radius,k=c-this.position.x,_=h.y+this.heightOffset-this.position.y,b=d-this.position.z;let p=k*this.cameraAcceleration*2,y=_*this.cameraAcceleration,C=b*this.cameraAcceleration*2;(p>this.maxCameraSpeed||p<-this.maxCameraSpeed)&&(p=p<1?-this.maxCameraSpeed:this.maxCameraSpeed),(y>this.maxCameraSpeed||y<-this.maxCameraSpeed)&&(y=y<1?-this.maxCameraSpeed:this.maxCameraSpeed),(C>this.maxCameraSpeed||C<-this.maxCameraSpeed)&&(C=C<1?-this.maxCameraSpeed:this.maxCameraSpeed),this.position=new g(this.position.x+p,this.position.y+y,this.position.z+C),this.setTarget(h)}attachControl(s,a){a=m.BackCompatCameraNoPreventDefault(arguments),this.inputs.attachElement(a),this._reset=()=>{}}detachControl(){this.inputs.detachElement(),this._reset&&this._reset()}_checkInputs(){this.inputs.checkInputs(),this._checkLimits(),super._checkInputs(),this.lockedTarget&&this._follow(this.lockedTarget)}_checkLimits(){this.lowerRadiusLimit!==null&&this.radius<this.lowerRadiusLimit&&(this.radius=this.lowerRadiusLimit),this.upperRadiusLimit!==null&&this.radius>this.upperRadiusLimit&&(this.radius=this.upperRadiusLimit),this.lowerHeightOffsetLimit!==null&&this.heightOffset<this.lowerHeightOffsetLimit&&(this.heightOffset=this.lowerHeightOffsetLimit),this.upperHeightOffsetLimit!==null&&this.heightOffset>this.upperHeightOffsetLimit&&(this.heightOffset=this.upperHeightOffsetLimit),this.lowerRotationOffsetLimit!==null&&this.rotationOffset<this.lowerRotationOffsetLimit&&(this.rotationOffset=this.lowerRotationOffsetLimit),this.upperRotationOffsetLimit!==null&&this.rotationOffset>this.upperRotationOffsetLimit&&(this.rotationOffset=this.upperRotationOffsetLimit)}getClassName(){return"FollowCamera"}}t([i()],l.prototype,"radius",void 0);t([i()],l.prototype,"lowerRadiusLimit",void 0);t([i()],l.prototype,"upperRadiusLimit",void 0);t([i()],l.prototype,"rotationOffset",void 0);t([i()],l.prototype,"lowerRotationOffsetLimit",void 0);t([i()],l.prototype,"upperRotationOffsetLimit",void 0);t([i()],l.prototype,"heightOffset",void 0);t([i()],l.prototype,"lowerHeightOffsetLimit",void 0);t([i()],l.prototype,"upperHeightOffsetLimit",void 0);t([i()],l.prototype,"cameraAcceleration",void 0);t([i()],l.prototype,"maxCameraSpeed",void 0);t([S("lockedTargetId")],l.prototype,"lockedTarget",void 0);class D extends v{constructor(s,a,e,o,h,c){super(s,g.Zero(),c),this.alpha=a,this.beta=e,this.radius=o,this._cartesianCoordinates=g.Zero(),this.setMeshTarget(h)}setMeshTarget(s){this._meshTarget=s,this._follow()}_follow(){if(!this._meshTarget)return;this._cartesianCoordinates.x=this.radius*Math.cos(this.alpha)*Math.cos(this.beta),this._cartesianCoordinates.y=this.radius*Math.sin(this.beta),this._cartesianCoordinates.z=this.radius*Math.sin(this.alpha)*Math.cos(this.beta);const s=this._meshTarget.getAbsolutePosition();this.position=s.add(this._cartesianCoordinates),this.setTarget(s)}_checkInputs(){super._checkInputs(),this._follow()}getClassName(){return"ArcFollowCamera"}}export{D as A,l as F,I as a,r as b,u as c,n as d};
