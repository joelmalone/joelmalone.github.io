import{a1 as d,ae as x,af as T,L as p}from"./runBabylonPlaygroundScene-32a4afbd.js";import{T as _}from"./linesBuilder-a2dae4c1.js";d.prototype.createDynamicTexture=function(n,e,t,i){const s=new x(this,T.Dynamic);return s.baseWidth=n,s.baseHeight=e,t&&(n=this.needPOTTextures?d.GetExponentOfTwo(n,this._caps.maxTextureSize):n,e=this.needPOTTextures?d.GetExponentOfTwo(e,this._caps.maxTextureSize):e),s.width=n,s.height=e,s.isReady=!1,s.generateMipMaps=t,s.samplingMode=i,this.updateTextureSamplingMode(i,s),this._internalTexturesCache.push(s),s};d.prototype.updateDynamicTexture=function(n,e,t,i=!1,s,c=!1,u=!1){if(!n)return;const h=this._gl,a=h.TEXTURE_2D,r=this._bindTextureDirectly(a,n,!0,c);this._unpackFlipY(t===void 0?n.invertY:t),i&&h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL,1);const l=this._getWebGLTextureType(n.type),o=this._getInternalFormat(s||n.format),g=this._getRGBABufferInternalSizedFormat(n.type,o);h.texImage2D(a,0,g,o,l,e),n.generateMipMaps&&h.generateMipmap(a),r||this._bindTextureDirectly(a,null),i&&h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL,0),n.isReady=!0};class f extends _{constructor(e,t,i=null,s=!1,c=3,u=5,h){super(null,i,!s,h,c,void 0,void 0,void 0,void 0,u),this.name=e,this.wrapU=_.CLAMP_ADDRESSMODE,this.wrapV=_.CLAMP_ADDRESSMODE,this._generateMipMaps=s;const a=this._getEngine();if(!a)return;t.getContext?(this._canvas=t,this._texture=a.createDynamicTexture(t.width,t.height,s,c)):(this._canvas=a.createCanvas(1,1),t.width||t.width===0?this._texture=a.createDynamicTexture(t.width,t.height,s,c):this._texture=a.createDynamicTexture(t,t,s,c));const r=this.getSize();this._canvas.width!==r.width&&(this._canvas.width=r.width),this._canvas.height!==r.height&&(this._canvas.height=r.height),this._context=this._canvas.getContext("2d")}getClassName(){return"DynamicTexture"}get canRescale(){return!0}_recreate(e){this._canvas.width=e.width,this._canvas.height=e.height,this.releaseInternalTexture(),this._texture=this._getEngine().createDynamicTexture(e.width,e.height,this._generateMipMaps,this.samplingMode)}scale(e){const t=this.getSize();t.width*=e,t.height*=e,this._recreate(t)}scaleTo(e,t){const i=this.getSize();i.width=e,i.height=t,this._recreate(i)}getContext(){return this._context}clear(){const e=this.getSize();this._context.fillRect(0,0,e.width,e.height)}update(e,t=!1,i=!1){this._getEngine().updateDynamicTexture(this._texture,this._canvas,e===void 0?!0:e,t,this._format||void 0,void 0,i)}drawText(e,t,i,s,c,u,h,a=!0){const r=this.getSize();if(u&&(this._context.fillStyle=u,this._context.fillRect(0,0,r.width,r.height)),this._context.font=s,t==null){const l=this._context.measureText(e);t=(r.width-l.width)/2}if(i==null){const l=parseInt(s.replace(/\D/g,""));i=r.height/2+l/3.65}this._context.fillStyle=c||"",this._context.fillText(e,t,i),a&&this.update(h)}clone(){const e=this.getScene();if(!e)return this;const t=this.getSize(),i=new f(this.name,t,e,this._generateMipMaps);return i.hasAlpha=this.hasAlpha,i.level=this.level,i.wrapU=this.wrapU,i.wrapV=this.wrapV,i}serialize(){const e=this.getScene();e&&!e.isReady()&&p.Warn("The scene must be ready before serializing the dynamic texture");const t=super.serialize();return f._IsCanvasElement(this._canvas)&&(t.base64String=this._canvas.toDataURL()),t.invertY=this._invertY,t.samplingMode=this.samplingMode,t}static _IsCanvasElement(e){return e.toDataURL!==void 0}_rebuild(){this.update()}}export{f as D};
