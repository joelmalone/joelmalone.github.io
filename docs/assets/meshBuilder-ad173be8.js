import{a7 as X,M as m,V as E,d as te,bg as se,h as ce,aa as $,v as pe,cv as Bt,q as Ke,f as ye,E as ut,bW as Xe,L as ae,ao as dt,bX as ke,g as be,bU as ee}from"./runBabylonPlaygroundScene-32a4afbd.js";import{a as Lt,b as Et,C as Rt,g as zt,e as Mt,c as Ut,o as St,f as Nt,q as Wt,x as Gt,r as kt}from"./linesBuilder-a2dae4c1.js";function ft(d){const e=d.sideOrientation||X.DEFAULTSIDE,t=d.radius||1,s=d.flat===void 0?!0:d.flat,a=d.subdivisions||4,h=d.radiusX||t,l=d.radiusY||t,r=d.radiusZ||t,c=(1+Math.sqrt(5))/2,x=[-1,c,-0,1,c,0,-1,-c,0,1,-c,0,0,-1,-c,0,1,-c,0,-1,c,0,1,c,c,0,1,c,0,-1,-c,0,1,-c,0,-1],v=[0,11,5,0,5,1,0,1,7,0,7,10,12,22,23,1,5,20,5,11,4,23,22,13,22,18,6,7,1,8,14,21,4,14,4,2,16,13,6,15,6,19,3,8,9,4,21,5,13,17,23,6,13,22,19,6,18,9,8,1],_=[0,1,2,3,4,5,6,7,8,9,10,11,0,2,3,3,3,4,7,8,9,9,10,11],g=[5,1,3,1,6,4,0,0,5,3,4,2,2,2,4,0,2,0,1,1,6,0,6,2,0,4,3,3,4,4,3,1,4,2,4,4,0,2,1,1,2,2,3,3,1,3,2,4],u=138/1024,i=239/1024,A=60/1024,O=26/1024,T=-40/1024,C=20/1024,P=[0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0],y=new Array,o=new Array,f=new Array,D=new Array;let z=0;const I=new Array(3),F=new Array(3);let b;for(b=0;b<3;b++)I[b]=E.Zero(),F[b]=te.Zero();for(let K=0;K<20;K++){for(b=0;b<3;b++){const G=v[3*K+b];I[b].copyFromFloats(x[3*_[G]],x[3*_[G]+1],x[3*_[G]+2]),I[b].normalize(),F[b].copyFromFloats(g[2*G]*u+A+P[K]*T,g[2*G+1]*i+O+P[K]*C)}const Y=(G,W,j,q)=>{const B=E.Lerp(I[0],I[2],W/a),w=E.Lerp(I[1],I[2],W/a),n=a===W?I[2]:E.Lerp(B,w,G/(a-W));n.normalize();let p;if(s){const k=E.Lerp(I[0],I[2],q/a),R=E.Lerp(I[1],I[2],q/a);p=E.Lerp(k,R,j/(a-q))}else p=new E(n.x,n.y,n.z);p.x/=h,p.y/=l,p.z/=r,p.normalize();const L=te.Lerp(F[0],F[2],W/a),M=te.Lerp(F[1],F[2],W/a),Q=a===W?F[2]:te.Lerp(L,M,G/(a-W));o.push(n.x*h,n.y*l,n.z*r),f.push(p.x,p.y,p.z),D.push(Q.x,se.UseOpenGLOrientationForUV?1-Q.y:Q.y),y.push(z),z++};for(let G=0;G<a;G++)for(let W=0;W+G<a;W++)Y(W,G,W+1/3,G+1/3),Y(W+1,G,W+1/3,G+1/3),Y(W,G+1,W+1/3,G+1/3),W+G+1<a&&(Y(W+1,G,W+2/3,G+2/3),Y(W+1,G+1,W+2/3,G+2/3),Y(W,G+1,W+2/3,G+2/3))}X._ComputeSides(e,o,y,f,D,d.frontUVs,d.backUVs);const V=new X;return V.indices=y,V.positions=o,V.normals=f,V.uvs=D,V}function He(d,e={},t=null){const s=new m(d,t);return e.sideOrientation=m._GetDefaultSideOrientation(e.sideOrientation),s._originalBuilderSideOrientation=e.sideOrientation,ft(e).applyToMesh(s,e.updatable),s}const rs={CreateIcoSphere:He};X.CreateIcoSphere=ft;m.CreateIcoSphere=(d,e,t)=>He(d,e,t);function xt(d={subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){const e=Math.max(d.subdivisions?d.subdivisions:2,1),t=Math.max(d.tessellation?d.tessellation:16,3),s=Math.max(d.height?d.height:1,0),a=Math.max(d.radius?d.radius:.25,0),h=Math.max(d.capSubdivisions?d.capSubdivisions:6,1),l=t,r=e,c=Math.max(d.radiusTop?d.radiusTop:a,0),x=Math.max(d.radiusBottom?d.radiusBottom:a,0),v=s-(c+x),_=0,g=2*Math.PI,u=Math.max(d.topCapSubdivisions?d.topCapSubdivisions:h,1),i=Math.max(d.bottomCapSubdivisions?d.bottomCapSubdivisions:h,1),A=Math.acos((x-c)/s);let O=[];const T=[],C=[],P=[];let y=0;const o=[],f=v*.5,D=Math.PI*.5;let z,I;const F=E.Zero(),b=E.Zero(),V=Math.cos(A),K=Math.sin(A),Y=new te(c*K,f+c*V).subtract(new te(x*K,-f+x*V)).length(),G=c*A+Y+x*(D-A);let W=0;for(I=0;I<=u;I++){const w=[],n=D-A*(I/u);W+=c*A/u;const p=Math.cos(n),L=Math.sin(n),M=p*c;for(z=0;z<=l;z++){const Q=z/l,k=Q*g+_,R=Math.sin(k),S=Math.cos(k);b.x=M*R,b.y=f+L*c,b.z=M*S,T.push(b.x,b.y,b.z),F.set(p*R,L,p*S),C.push(F.x,F.y,F.z),P.push(Q,se.UseOpenGLOrientationForUV?W/G:1-W/G),w.push(y),y++}o.push(w)}const j=s-c-x+V*c-V*x,q=K*(x-c)/j;for(I=1;I<=r;I++){const w=[];W+=Y/r;const n=K*(I*(x-c)/r+c);for(z=0;z<=l;z++){const p=z/l,L=p*g+_,M=Math.sin(L),Q=Math.cos(L);b.x=n*M,b.y=f+V*c-I*j/r,b.z=n*Q,T.push(b.x,b.y,b.z),F.set(M,q,Q).normalize(),C.push(F.x,F.y,F.z),P.push(p,se.UseOpenGLOrientationForUV?W/G:1-W/G),w.push(y),y++}o.push(w)}for(I=1;I<=i;I++){const w=[],n=D-A-(Math.PI-A)*(I/i);W+=x*A/i;const p=Math.cos(n),L=Math.sin(n),M=p*x;for(z=0;z<=l;z++){const Q=z/l,k=Q*g+_,R=Math.sin(k),S=Math.cos(k);b.x=M*R,b.y=-f+L*x,b.z=M*S,T.push(b.x,b.y,b.z),F.set(p*R,L,p*S),C.push(F.x,F.y,F.z),P.push(Q,se.UseOpenGLOrientationForUV?W/G:1-W/G),w.push(y),y++}o.push(w)}for(z=0;z<l;z++)for(I=0;I<u+r+i;I++){const w=o[I][z],n=o[I+1][z],p=o[I+1][z+1],L=o[I][z+1];O.push(w),O.push(n),O.push(L),O.push(n),O.push(p),O.push(L)}if(O=O.reverse(),d.orientation&&!d.orientation.equals(E.Up())){const w=new ce;d.orientation.clone().scale(Math.PI*.5).cross(E.Up()).toQuaternion().toRotationMatrix(w);const n=E.Zero();for(let p=0;p<T.length;p+=3)n.set(T[p],T[p+1],T[p+2]),E.TransformCoordinatesToRef(n.clone(),w,n),T[p]=n.x,T[p+1]=n.y,T[p+2]=n.z}const B=new X;return B.positions=T,B.normals=C,B.uvs=P,B.indices=O,B}function Ye(d,e={orientation:E.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6,updatable:!1},t=null){const s=new m(d,t);return xt(e).applyToMesh(s,e.updatable),s}const is={CreateCapsule:Ye};m.CreateCapsule=(d,e,t)=>Ye(d,e,t);X.CreateCapsule=xt;function gt(d){let e=d.pathArray;const t=d.closeArray||!1,s=d.closePath||!1,a=d.invertUV||!1,h=Math.floor(e[0].length/2);let l=d.offset||h;l=l>h?h:Math.floor(l);const r=d.sideOrientation===0?0:d.sideOrientation||X.DEFAULTSIDE,c=d.uvs,x=d.colors,v=[],_=[],g=[],u=[],i=[],A=[],O=[],T=[];let C;const P=[],y=[];let o,f,D;if(e.length<2){const Z=[],N=[];for(f=0;f<e[0].length-l;f++)Z.push(e[0][f]),N.push(e[0][f+l]);e=[Z,N]}let z=0;const I=s?1:0;let F,b;C=e[0].length;let V,K;for(o=0;o<e.length;o++){for(O[o]=0,i[o]=[0],F=e[o],b=F.length,C=C<b?C:b,D=0;D<b;)v.push(F[D].x,F[D].y,F[D].z),D>0&&(V=F[D].subtract(F[D-1]).length(),K=V+O[o],i[o].push(K),O[o]=K),D++;s&&(D--,v.push(F[0].x,F[0].y,F[0].z),V=F[D].subtract(F[0]).length(),K=V+O[o],i[o].push(K),O[o]=K),P[o]=b+I,y[o]=z,z+=b+I}let Y,G,W=null,j=null;for(f=0;f<C+I;f++){for(T[f]=0,A[f]=[0],o=0;o<e.length-1;o++)Y=e[o],G=e[o+1],f===C?(W=Y[0],j=G[0]):(W=Y[f],j=G[f]),V=j.subtract(W).length(),K=V+T[f],A[f].push(K),T[f]=K;t&&j&&W&&(Y=e[o],G=e[0],f===C&&(j=G[0]),V=j.subtract(W).length(),K=V+T[f],T[f]=K)}let q,B;if(c)for(o=0;o<c.length;o++)u.push(c[o].x,se.UseOpenGLOrientationForUV?1-c[o].y:c[o].y);else for(o=0;o<e.length;o++)for(f=0;f<C+I;f++)q=O[o]!=0?i[o][f]/O[o]:0,B=T[f]!=0?A[f][o]/T[f]:0,a?u.push(B,q):u.push(q,se.UseOpenGLOrientationForUV?1-B:B);o=0;let w=0,n=P[o]-1,p=P[o+1]-1,L=n<p?n:p,M=y[1]-y[0];const Q=t?P.length:P.length-1;for(;w<=L&&o<Q;)_.push(w,w+M,w+1),_.push(w+M+1,w+1,w+M),w+=1,w===L&&(o++,o===P.length-1?(M=y[0]-y[o],n=P[o]-1,p=P[0]-1):(M=y[o+1]-y[o],n=P[o]-1,p=P[o+1]-1),w=y[o],L=n<p?n+w:p+w);if(X.ComputeNormals(v,_,g),s){let Z=0,N=0;for(o=0;o<e.length;o++)Z=y[o]*3,o+1<e.length?N=(y[o+1]-1)*3:N=g.length-3,g[Z]=(g[Z]+g[N])*.5,g[Z+1]=(g[Z+1]+g[N+1])*.5,g[Z+2]=(g[Z+2]+g[N+2])*.5,g[N]=g[Z],g[N+1]=g[Z+1],g[N+2]=g[Z+2]}X._ComputeSides(r,v,_,g,u,d.frontUVs,d.backUVs);let k=null;if(x){k=new Float32Array(x.length*4);for(let Z=0;Z<x.length;Z++)k[Z*4]=x[Z].r,k[Z*4+1]=x[Z].g,k[Z*4+2]=x[Z].b,k[Z*4+3]=x[Z].a}const R=new X,S=new Float32Array(v),H=new Float32Array(g),U=new Float32Array(u);return R.indices=_,R.positions=S,R.normals=H,R.uvs=U,k&&R.set(k,$.ColorKind),s&&(R._idx=y),R}function xe(d,e,t=null){const s=e.pathArray,a=e.closeArray,h=e.closePath,l=m._GetDefaultSideOrientation(e.sideOrientation),r=e.instance,c=e.updatable;if(r){const x=pe.Vector3[0].setAll(Number.MAX_VALUE),v=pe.Vector3[1].setAll(-Number.MAX_VALUE),_=u=>{let i=s[0].length;const A=r;let O=0;const T=A._originalBuilderSideOrientation===m.DOUBLESIDE?2:1;for(let C=1;C<=T;++C)for(let P=0;P<s.length;++P){const y=s[P],o=y.length;i=i<o?i:o;for(let f=0;f<i;++f){const D=y[f];u[O]=D.x,u[O+1]=D.y,u[O+2]=D.z,x.minimizeInPlaceFromFloats(D.x,D.y,D.z),v.maximizeInPlaceFromFloats(D.x,D.y,D.z),O+=3}if(A._creationDataStorage&&A._creationDataStorage.closePath){const f=y[0];u[O]=f.x,u[O+1]=f.y,u[O+2]=f.z,O+=3}}},g=r.getVerticesData($.PositionKind);if(_(g),r.hasBoundingInfo?r.getBoundingInfo().reConstruct(x,v,r._worldMatrix):r.buildBoundingInfo(x,v,r._worldMatrix),r.updateVerticesData($.PositionKind,g,!1,!1),e.colors){const u=r.getVerticesData($.ColorKind);for(let i=0,A=0;i<e.colors.length;i++,A+=4){const O=e.colors[i];u[A]=O.r,u[A+1]=O.g,u[A+2]=O.b,u[A+3]=O.a}r.updateVerticesData($.ColorKind,u,!1,!1)}if(e.uvs){const u=r.getVerticesData($.UVKind);for(let i=0;i<e.uvs.length;i++)u[i*2]=e.uvs[i].x,u[i*2+1]=se.UseOpenGLOrientationForUV?1-e.uvs[i].y:e.uvs[i].y;r.updateVerticesData($.UVKind,u,!1,!1)}if(!r.areNormalsFrozen||r.isFacetDataEnabled){const u=r.getIndices(),i=r.getVerticesData($.NormalKind),A=r.isFacetDataEnabled?r.getFacetDataParameters():null;if(X.ComputeNormals(g,u,i,A),r._creationDataStorage&&r._creationDataStorage.closePath){let O=0,T=0;for(let C=0;C<s.length;C++)O=r._creationDataStorage.idx[C]*3,C+1<s.length?T=(r._creationDataStorage.idx[C+1]-1)*3:T=i.length-3,i[O]=(i[O]+i[T])*.5,i[O+1]=(i[O+1]+i[T+1])*.5,i[O+2]=(i[O+2]+i[T+2])*.5,i[T]=i[O],i[T+1]=i[O+1],i[T+2]=i[O+2]}r.areNormalsFrozen||r.updateVerticesData($.NormalKind,i,!1,!1)}return r}else{const x=new m(d,t);x._originalBuilderSideOrientation=l,x._creationDataStorage=new Bt;const v=gt(e);return h&&(x._creationDataStorage.idx=v._idx),x._creationDataStorage.closePath=h,x._creationDataStorage.closeArray=a,v.applyToMesh(x,c),x}}const cs={CreateRibbon:xe};X.CreateRibbon=gt;m.CreateRibbon=(d,e,t=!1,s,a,h,l=!1,r,c)=>xe(d,{pathArray:e,closeArray:t,closePath:s,offset:a,updatable:l,sideOrientation:r,instance:c},h);function pt(d){const e=new Array,t=new Array,s=new Array,a=new Array,h=d.radius||.5,l=d.tessellation||64,r=d.arc&&(d.arc<=0||d.arc>1)?1:d.arc||1,c=d.sideOrientation===0?0:d.sideOrientation||X.DEFAULTSIDE;e.push(0,0,0),a.push(.5,.5);const x=Math.PI*2*r,v=r===1?x/l:x/(l-1);let _=0;for(let i=0;i<l;i++){const A=Math.cos(_),O=Math.sin(_),T=(A+1)/2,C=(1-O)/2;e.push(h*A,h*O,0),a.push(T,se.UseOpenGLOrientationForUV?1-C:C),_+=v}r===1&&(e.push(e[3],e[4],e[5]),a.push(a[2],se.UseOpenGLOrientationForUV?1-a[3]:a[3]));const g=e.length/3;for(let i=1;i<g-1;i++)t.push(i+1,0,i);X.ComputeNormals(e,t,s),X._ComputeSides(c,e,t,s,a,d.frontUVs,d.backUVs);const u=new X;return u.indices=t,u.positions=e,u.normals=s,u.uvs=a,u}function je(d,e={},t=null){const s=new m(d,t);return e.sideOrientation=m._GetDefaultSideOrientation(e.sideOrientation),s._originalBuilderSideOrientation=e.sideOrientation,pt(e).applyToMesh(s,e.updatable),s}const ls={CreateDisc:je};X.CreateDisc=pt;m.CreateDisc=(d,e,t,s=null,a,h)=>je(d,{radius:e,tessellation:t,sideOrientation:h,updatable:a},s);function ve(d){const e=d.pattern||m.NO_FLIP,t=d.tileWidth||d.tileSize||1,s=d.tileHeight||d.tileSize||1,a=d.alignHorizontal||0,h=d.alignVertical||0,l=d.width||d.size||1,r=Math.floor(l/t);let c=l-r*t;const x=d.height||d.size||1,v=Math.floor(x/s);let _=x-v*s;const g=t*r/2,u=s*v/2;let i=0,A=0,O=0,T=0,C=0,P=0;if(c>0||_>0){switch(O=-g,T=-u,C=g,P=u,a){case m.CENTER:c/=2,O-=c,C+=c;break;case m.LEFT:C+=c,i=-c/2;break;case m.RIGHT:O-=c,i=c/2;break}switch(h){case m.CENTER:_/=2,T-=_,P+=_;break;case m.BOTTOM:P+=_,A=-_/2;break;case m.TOP:T-=_,A=_/2;break}}const y=[],o=[],f=[];f[0]=[0,0,1,0,1,1,0,1],f[1]=[0,0,1,0,1,1,0,1],(e===m.ROTATE_TILE||e===m.ROTATE_ROW)&&(f[1]=[1,1,0,1,0,0,1,0]),(e===m.FLIP_TILE||e===m.FLIP_ROW)&&(f[1]=[1,0,0,0,0,1,1,1]),(e===m.FLIP_N_ROTATE_TILE||e===m.FLIP_N_ROTATE_ROW)&&(f[1]=[0,1,1,1,1,0,0,0]);let D=[];const z=[],I=[];let F=0;for(let Y=0;Y<v;Y++)for(let G=0;G<r;G++)y.push(-g+G*t+i,-u+Y*s+A,0),y.push(-g+(G+1)*t+i,-u+Y*s+A,0),y.push(-g+(G+1)*t+i,-u+(Y+1)*s+A,0),y.push(-g+G*t+i,-u+(Y+1)*s+A,0),I.push(F,F+1,F+3,F+1,F+2,F+3),e===m.FLIP_TILE||e===m.ROTATE_TILE||e===m.FLIP_N_ROTATE_TILE?D=D.concat(f[(G%2+Y%2)%2]):e===m.FLIP_ROW||e===m.ROTATE_ROW||e===m.FLIP_N_ROTATE_ROW?D=D.concat(f[Y%2]):D=D.concat(f[0]),z.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),o.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1),F+=4;if(c>0||_>0){const Y=_>0&&(h===m.CENTER||h===m.TOP),G=_>0&&(h===m.CENTER||h===m.BOTTOM),W=c>0&&(a===m.CENTER||a===m.RIGHT),j=c>0&&(a===m.CENTER||a===m.LEFT);let q=[],B,w,n,p;if(Y&&W&&(y.push(O+i,T+A,0),y.push(-g+i,T+A,0),y.push(-g+i,T+_+A,0),y.push(O+i,T+_+A,0),I.push(F,F+1,F+3,F+1,F+2,F+3),F+=4,B=1-c/t,w=1-_/s,n=1,p=1,q=[B,w,n,w,n,p,B,p],e===m.ROTATE_ROW&&(q=[1-B,1-w,1-n,1-w,1-n,1-p,1-B,1-p]),e===m.FLIP_ROW&&(q=[1-B,w,1-n,w,1-n,p,1-B,p]),e===m.FLIP_N_ROTATE_ROW&&(q=[B,1-w,n,1-w,n,1-p,B,1-p]),D=D.concat(q),z.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),o.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),Y&&j&&(y.push(g+i,T+A,0),y.push(C+i,T+A,0),y.push(C+i,T+_+A,0),y.push(g+i,T+_+A,0),I.push(F,F+1,F+3,F+1,F+2,F+3),F+=4,B=0,w=1-_/s,n=c/t,p=1,q=[B,w,n,w,n,p,B,p],(e===m.ROTATE_ROW||e===m.ROTATE_TILE&&r%2===0)&&(q=[1-B,1-w,1-n,1-w,1-n,1-p,1-B,1-p]),(e===m.FLIP_ROW||e===m.FLIP_TILE&&r%2===0)&&(q=[1-B,w,1-n,w,1-n,p,1-B,p]),(e===m.FLIP_N_ROTATE_ROW||e===m.FLIP_N_ROTATE_TILE&&r%2===0)&&(q=[B,1-w,n,1-w,n,1-p,B,1-p]),D=D.concat(q),z.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),o.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),G&&W&&(y.push(O+i,u+A,0),y.push(-g+i,u+A,0),y.push(-g+i,P+A,0),y.push(O+i,P+A,0),I.push(F,F+1,F+3,F+1,F+2,F+3),F+=4,B=1-c/t,w=0,n=1,p=_/s,q=[B,w,n,w,n,p,B,p],(e===m.ROTATE_ROW&&v%2===1||e===m.ROTATE_TILE&&v%1===0)&&(q=[1-B,1-w,1-n,1-w,1-n,1-p,1-B,1-p]),(e===m.FLIP_ROW&&v%2===1||e===m.FLIP_TILE&&v%2===0)&&(q=[1-B,w,1-n,w,1-n,p,1-B,p]),(e===m.FLIP_N_ROTATE_ROW&&v%2===1||e===m.FLIP_N_ROTATE_TILE&&v%2===0)&&(q=[B,1-w,n,1-w,n,1-p,B,1-p]),D=D.concat(q),z.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),o.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),G&&j&&(y.push(g+i,u+A,0),y.push(C+i,u+A,0),y.push(C+i,P+A,0),y.push(g+i,P+A,0),I.push(F,F+1,F+3,F+1,F+2,F+3),F+=4,B=0,w=0,n=c/t,p=_/s,q=[B,w,n,w,n,p,B,p],(e===m.ROTATE_ROW&&v%2===1||e===m.ROTATE_TILE&&(v+r)%2===1)&&(q=[1-B,1-w,1-n,1-w,1-n,1-p,1-B,1-p]),(e===m.FLIP_ROW&&v%2===1||e===m.FLIP_TILE&&(v+r)%2===1)&&(q=[1-B,w,1-n,w,1-n,p,1-B,p]),(e===m.FLIP_N_ROTATE_ROW&&v%2===1||e===m.FLIP_N_ROTATE_TILE&&(v+r)%2===1)&&(q=[B,1-w,n,1-w,n,1-p,B,1-p]),D=D.concat(q),z.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),o.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),Y){const L=[];B=0,w=1-_/s,n=1,p=1,L[0]=[B,w,n,w,n,p,B,p],L[1]=[B,w,n,w,n,p,B,p],(e===m.ROTATE_TILE||e===m.ROTATE_ROW)&&(L[1]=[1-B,1-w,1-n,1-w,1-n,1-p,1-B,1-p]),(e===m.FLIP_TILE||e===m.FLIP_ROW)&&(L[1]=[1-B,w,1-n,w,1-n,p,1-B,p]),(e===m.FLIP_N_ROTATE_TILE||e===m.FLIP_N_ROTATE_ROW)&&(L[1]=[B,1-w,n,1-w,n,1-p,B,1-p]);for(let M=0;M<r;M++)y.push(-g+M*t+i,T+A,0),y.push(-g+(M+1)*t+i,T+A,0),y.push(-g+(M+1)*t+i,T+_+A,0),y.push(-g+M*t+i,T+_+A,0),I.push(F,F+1,F+3,F+1,F+2,F+3),F+=4,e===m.FLIP_TILE||e===m.ROTATE_TILE||e===m.FLIP_N_ROTATE_TILE?D=D.concat(L[(M+1)%2]):e===m.FLIP_ROW||e===m.ROTATE_ROW||e===m.FLIP_N_ROTATE_ROW?D=D.concat(L[1]):D=D.concat(L[0]),z.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),o.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(G){const L=[];B=0,w=0,n=1,p=_/s,L[0]=[B,w,n,w,n,p,B,p],L[1]=[B,w,n,w,n,p,B,p],(e===m.ROTATE_TILE||e===m.ROTATE_ROW)&&(L[1]=[1-B,1-w,1-n,1-w,1-n,1-p,1-B,1-p]),(e===m.FLIP_TILE||e===m.FLIP_ROW)&&(L[1]=[1-B,w,1-n,w,1-n,p,1-B,p]),(e===m.FLIP_N_ROTATE_TILE||e===m.FLIP_N_ROTATE_ROW)&&(L[1]=[B,1-w,n,1-w,n,1-p,B,1-p]);for(let M=0;M<r;M++)y.push(-g+M*t+i,P-_+A,0),y.push(-g+(M+1)*t+i,P-_+A,0),y.push(-g+(M+1)*t+i,P+A,0),y.push(-g+M*t+i,P+A,0),I.push(F,F+1,F+3,F+1,F+2,F+3),F+=4,e===m.FLIP_TILE||e===m.ROTATE_TILE||e===m.FLIP_N_ROTATE_TILE?D=D.concat(L[(M+v)%2]):e===m.FLIP_ROW||e===m.ROTATE_ROW||e===m.FLIP_N_ROTATE_ROW?D=D.concat(L[v%2]):D=D.concat(L[0]),z.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),o.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(W){const L=[];B=1-c/t,w=0,n=1,p=1,L[0]=[B,w,n,w,n,p,B,p],L[1]=[B,w,n,w,n,p,B,p],(e===m.ROTATE_TILE||e===m.ROTATE_ROW)&&(L[1]=[1-B,1-w,1-n,1-w,1-n,1-p,1-B,1-p]),(e===m.FLIP_TILE||e===m.FLIP_ROW)&&(L[1]=[1-B,w,1-n,w,1-n,p,1-B,p]),(e===m.FLIP_N_ROTATE_TILE||e===m.FLIP_N_ROTATE_ROW)&&(L[1]=[B,1-w,n,1-w,n,1-p,B,1-p]);for(let M=0;M<v;M++)y.push(O+i,-u+M*s+A,0),y.push(O+c+i,-u+M*s+A,0),y.push(O+c+i,-u+(M+1)*s+A,0),y.push(O+i,-u+(M+1)*s+A,0),I.push(F,F+1,F+3,F+1,F+2,F+3),F+=4,e===m.FLIP_TILE||e===m.ROTATE_TILE||e===m.FLIP_N_ROTATE_TILE?D=D.concat(L[(M+1)%2]):e===m.FLIP_ROW||e===m.ROTATE_ROW||e===m.FLIP_N_ROTATE_ROW?D=D.concat(L[M%2]):D=D.concat(L[0]),z.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),o.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(j){const L=[];B=0,w=0,n=c/s,p=1,L[0]=[B,w,n,w,n,p,B,p],L[1]=[B,w,n,w,n,p,B,p],(e===m.ROTATE_TILE||e===m.ROTATE_ROW)&&(L[1]=[1-B,1-w,1-n,1-w,1-n,1-p,1-B,1-p]),(e===m.FLIP_TILE||e===m.FLIP_ROW)&&(L[1]=[1-B,w,1-n,w,1-n,p,1-B,p]),(e===m.FLIP_N_ROTATE_TILE||e===m.FLIP_N_ROTATE_ROW)&&(L[1]=[B,1-w,n,1-w,n,1-p,B,1-p]);for(let M=0;M<v;M++)y.push(C-c+i,-u+M*s+A,0),y.push(C+i,-u+M*s+A,0),y.push(C+i,-u+(M+1)*s+A,0),y.push(C-c+i,-u+(M+1)*s+A,0),I.push(F,F+1,F+3,F+1,F+2,F+3),F+=4,e===m.FLIP_TILE||e===m.ROTATE_TILE||e===m.FLIP_N_ROTATE_TILE?D=D.concat(L[(M+r)%2]):e===m.FLIP_ROW||e===m.ROTATE_ROW||e===m.FLIP_N_ROTATE_ROW?D=D.concat(L[M%2]):D=D.concat(L[0]),z.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),o.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}}const b=d.sideOrientation===0?0:d.sideOrientation||X.DEFAULTSIDE;X._ComputeSides(b,y,I,o,D,d.frontUVs,d.backUVs);const V=new X;V.indices=I,V.positions=y,V.normals=o,V.uvs=D;const K=b===X.DOUBLESIDE?z.concat(z):z;return V.colors=K,V}function mt(d,e,t=null){const s=new m(d,t);return e.sideOrientation=m._GetDefaultSideOrientation(e.sideOrientation),s._originalBuilderSideOrientation=e.sideOrientation,ve(e).applyToMesh(s,e.updatable),s}const hs={CreateTiledPlane:mt};X.CreateTiledPlane=ve;function Ot(d){const t=d.faceUV||new Array(6),s=d.faceColors,a=d.pattern||m.NO_FLIP,h=d.width||d.size||1,l=d.height||d.size||1,r=d.depth||d.size||1,c=d.tileWidth||d.tileSize||1,x=d.tileHeight||d.tileSize||1,v=d.alignHorizontal||0,_=d.alignVertical||0,g=d.sideOrientation===0?0:d.sideOrientation||X.DEFAULTSIDE;for(let n=0;n<6;n++)t[n]===void 0&&(t[n]=new Ke(0,0,1,1)),s&&s[n]===void 0&&(s[n]=new ye(1,1,1,1));const u=h/2,i=l/2,A=r/2,O=[];for(let n=0;n<2;n++)O[n]=ve({pattern:a,tileWidth:c,tileHeight:x,width:h,height:l,alignVertical:_,alignHorizontal:v,sideOrientation:g});for(let n=2;n<4;n++)O[n]=ve({pattern:a,tileWidth:c,tileHeight:x,width:r,height:l,alignVertical:_,alignHorizontal:v,sideOrientation:g});let T=_;_===m.BOTTOM?T=m.TOP:_===m.TOP&&(T=m.BOTTOM);for(let n=4;n<6;n++)O[n]=ve({pattern:a,tileWidth:c,tileHeight:x,width:h,height:r,alignVertical:T,alignHorizontal:v,sideOrientation:g});let C=[],P=[],y=[],o=[];const f=[],D=[],z=[],I=[];let F=0,b=0;for(let n=0;n<6;n++){const p=O[n].positions.length;D[n]=[],z[n]=[];for(let L=0;L<p/3;L++)D[n].push(new E(O[n].positions[3*L],O[n].positions[3*L+1],O[n].positions[3*L+2])),z[n].push(new E(O[n].normals[3*L],O[n].normals[3*L+1],O[n].normals[3*L+2]));F=O[n].uvs.length,I[n]=[];for(let L=0;L<F;L+=2)I[n][L]=t[n].x+(t[n].z-t[n].x)*O[n].uvs[L],I[n][L+1]=t[n].y+(t[n].w-t[n].y)*O[n].uvs[L+1],se.UseOpenGLOrientationForUV&&(I[n][L+1]=1-I[n][L+1]);if(y=y.concat(I[n]),o=o.concat(O[n].indices.map(L=>L+b)),b+=D[n].length,s)for(let L=0;L<4;L++)f.push(s[n].r,s[n].g,s[n].b,s[n].a)}const V=new E(0,0,A),K=ce.RotationY(Math.PI);C=D[0].map(n=>E.TransformNormal(n,K).add(V)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[]),P=z[0].map(n=>E.TransformNormal(n,K)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[]),C=C.concat(D[1].map(n=>n.subtract(V)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[])),P=P.concat(z[1].map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[]));const Y=new E(u,0,0),G=ce.RotationY(-Math.PI/2);C=C.concat(D[2].map(n=>E.TransformNormal(n,G).add(Y)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[])),P=P.concat(z[2].map(n=>E.TransformNormal(n,G)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[]));const W=ce.RotationY(Math.PI/2);C=C.concat(D[3].map(n=>E.TransformNormal(n,W).subtract(Y)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[])),P=P.concat(z[3].map(n=>E.TransformNormal(n,W)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[]));const j=new E(0,i,0),q=ce.RotationX(Math.PI/2);C=C.concat(D[4].map(n=>E.TransformNormal(n,q).add(j)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[])),P=P.concat(z[4].map(n=>E.TransformNormal(n,q)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[]));const B=ce.RotationX(-Math.PI/2);C=C.concat(D[5].map(n=>E.TransformNormal(n,B).subtract(j)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[])),P=P.concat(z[5].map(n=>E.TransformNormal(n,B)).map(n=>[n.x,n.y,n.z]).reduce((n,p)=>n.concat(p),[])),X._ComputeSides(g,C,o,P,y);const w=new X;if(w.indices=o,w.positions=C,w.normals=P,w.uvs=y,s){const n=g===X.DOUBLESIDE?f.concat(f):f;w.colors=n}return w}function vt(d,e,t=null){const s=new m(d,t);return e.sideOrientation=m._GetDefaultSideOrientation(e.sideOrientation),s._originalBuilderSideOrientation=e.sideOrientation,Ot(e).applyToMesh(s,e.updatable),s}const ds={CreateTiledBox:vt};X.CreateTiledBox=Ot;function yt(d){const e=new Array,t=new Array,s=new Array,a=new Array,h=d.radius||2,l=d.tube||.5,r=d.radialSegments||32,c=d.tubularSegments||32,x=d.p||2,v=d.q||3,_=d.sideOrientation===0?0:d.sideOrientation||X.DEFAULTSIDE,g=O=>{const T=Math.cos(O),C=Math.sin(O),P=v/x*O,y=Math.cos(P),o=h*(2+y)*.5*T,f=h*(2+y)*C*.5,D=h*Math.sin(P)*.5;return new E(o,f,D)};let u,i;for(u=0;u<=r;u++){const T=u%r/r*2*x*Math.PI,C=g(T),P=g(T+.01),y=P.subtract(C);let o=P.add(C);const f=E.Cross(y,o);for(o=E.Cross(f,y),f.normalize(),o.normalize(),i=0;i<c;i++){const z=i%c/c*2*Math.PI,I=-l*Math.cos(z),F=l*Math.sin(z);t.push(C.x+I*o.x+F*f.x),t.push(C.y+I*o.y+F*f.y),t.push(C.z+I*o.z+F*f.z),a.push(u/r),a.push(se.UseOpenGLOrientationForUV?1-i/c:i/c)}}for(u=0;u<r;u++)for(i=0;i<c;i++){const O=(i+1)%c,T=u*c+i,C=(u+1)*c+i,P=(u+1)*c+O,y=u*c+O;e.push(y),e.push(C),e.push(T),e.push(y),e.push(P),e.push(C)}X.ComputeNormals(t,e,s),X._ComputeSides(_,t,e,s,a,d.frontUVs,d.backUVs);const A=new X;return A.indices=e,A.positions=t,A.normals=s,A.uvs=a,A}function qe(d,e={},t){const s=new m(d,t);return e.sideOrientation=m._GetDefaultSideOrientation(e.sideOrientation),s._originalBuilderSideOrientation=e.sideOrientation,yt(e).applyToMesh(s,e.updatable),s}const us={CreateTorusKnot:qe};X.CreateTorusKnot=yt;m.CreateTorusKnot=(d,e,t,s,a,h,l,r,c,x)=>qe(d,{radius:e,tube:t,radialSegments:s,tubularSegments:a,p:h,q:l,sideOrientation:x,updatable:c},r);class Zt extends te{constructor(e,t){super(e.x,e.y),this.index=t}}class Ge{constructor(){this.elements=new Array}add(e){const t=new Array;return e.forEach(s=>{const a=new Zt(s,this.elements.length);t.push(a),this.elements.push(a)}),t}computeBounds(){const e=new te(this.elements[0].x,this.elements[0].y),t=new te(this.elements[0].x,this.elements[0].y);return this.elements.forEach(s=>{s.x<e.x?e.x=s.x:s.x>t.x&&(t.x=s.x),s.y<e.y?e.y=s.y:s.y>t.y&&(t.y=s.y)}),{min:e,max:t,width:t.x-e.x,height:t.y-e.y}}}class fs{static Rectangle(e,t,s,a){return[new te(e,t),new te(s,t),new te(s,a),new te(e,a)]}static Circle(e,t=0,s=0,a=32){const h=new Array;let l=0;const r=Math.PI*2/a;for(let c=0;c<a;c++)h.push(new te(t+Math.cos(l)*e,s+Math.sin(l)*e)),l-=r;return h}static Parse(e){const t=e.split(/[^-+eE.\d]+/).map(parseFloat).filter(h=>!isNaN(h));let s;const a=[];for(s=0;s<(t.length&2147483646);s+=2)a.push(new te(t[s],t[s+1]));return a}static StartingAt(e,t){return Xe.StartingAt(e,t)}}class Kt{_addToepoint(e){for(const t of e)this._epoints.push(t.x,t.y)}constructor(e,t,s,a=earcut){this._points=new Ge,this._outlinepoints=new Ge,this._holes=new Array,this._epoints=new Array,this._eholes=new Array,this.bjsEarcut=a,this._name=e,this._scene=s||ut.LastCreatedScene;let h;t instanceof Xe?h=t.getPoints():h=t,this._addToepoint(h),this._points.add(h),this._outlinepoints.add(h),typeof this.bjsEarcut>"u"&&ae.Warn("Earcut was not found, the polygon will not be built.")}addHole(e){this._points.add(e);const t=new Ge;return t.add(e),this._holes.push(t),this._eholes.push(this._epoints.length/2),this._addToepoint(e),this}build(e=!1,t=0,s=2){const a=new m(this._name,this._scene),h=this.buildVertexData(t,s);return a.setVerticesData($.PositionKind,h.positions,e),a.setVerticesData($.NormalKind,h.normals,e),a.setVerticesData($.UVKind,h.uvs,e),a.setIndices(h.indices),a}buildVertexData(e=0,t=2){const s=new X,a=new Array,h=new Array,l=new Array,r=this._points.computeBounds();this._points.elements.forEach(v=>{a.push(0,1,0),h.push(v.x,0,v.y),l.push((v.x-r.min.x)/r.width,(v.y-r.min.y)/r.height)});const c=new Array,x=this.bjsEarcut(this._epoints,this._eholes,2);for(let v=0;v<x.length;v++)c.push(x[v]);if(e>0){const v=h.length/3;this._points.elements.forEach(g=>{a.push(0,-1,0),h.push(g.x,-e,g.y),l.push(1-(g.x-r.min.x)/r.width,1-(g.y-r.min.y)/r.height)});const _=c.length;for(let g=0;g<_;g+=3){const u=c[g+0],i=c[g+1],A=c[g+2];c.push(A+v),c.push(i+v),c.push(u+v)}this._addSide(h,a,l,c,r,this._outlinepoints,e,!1,t),this._holes.forEach(g=>{this._addSide(h,a,l,c,r,g,e,!0,t)})}return s.indices=c,s.positions=h,s.normals=a,s.uvs=l,s}_addSide(e,t,s,a,h,l,r,c,x){let v=e.length/3,_=0;for(let g=0;g<l.elements.length;g++){const u=l.elements[g],i=l.elements[(g+1)%l.elements.length];e.push(u.x,0,u.y),e.push(u.x,-r,u.y),e.push(i.x,0,i.y),e.push(i.x,-r,i.y);const A=l.elements[(g+l.elements.length-1)%l.elements.length],O=l.elements[(g+2)%l.elements.length];let T=new E(-(i.y-u.y),0,i.x-u.x),C=new E(-(u.y-A.y),0,u.x-A.x),P=new E(-(O.y-i.y),0,O.x-i.x);c||(T=T.scale(-1),C=C.scale(-1),P=P.scale(-1));const y=T.normalizeToNew();let o=C.normalizeToNew(),f=P.normalizeToNew();const D=E.Dot(o,y);D>x?D<dt-1?o=new E(u.x,0,u.y).subtract(new E(i.x,0,i.y)).normalize():o=C.add(T).normalize():o=y;const z=E.Dot(P,T);z>x?z<dt-1?f=new E(i.x,0,i.y).subtract(new E(u.x,0,u.y)).normalize():f=P.add(T).normalize():f=y,s.push(_/h.width,0),s.push(_/h.width,1),_+=T.length(),s.push(_/h.width,0),s.push(_/h.width,1),t.push(o.x,o.y,o.z),t.push(o.x,o.y,o.z),t.push(f.x,f.y,f.z),t.push(f.x,f.y,f.z),c?(a.push(v),a.push(v+2),a.push(v+1),a.push(v+1),a.push(v+2),a.push(v+3)):(a.push(v),a.push(v+1),a.push(v+2),a.push(v+1),a.push(v+3),a.push(v+2)),v+=4}}}function At(d,e,t,s,a,h,l){const r=t||new Array(3),c=s,x=[],v=l||!1;for(let I=0;I<3;I++)r[I]===void 0&&(r[I]=new Ke(0,0,1,1)),c&&c[I]===void 0&&(c[I]=new ye(1,1,1,1));const _=d.getVerticesData($.PositionKind),g=d.getVerticesData($.NormalKind),u=d.getVerticesData($.UVKind),i=d.getIndices(),A=_.length/9;let O=0,T=0,C=0,P=0,y=0;const o=[0];if(v)for(let I=A;I<_.length/3;I+=4)T=_[3*(I+2)]-_[3*I],C=_[3*(I+2)+2]-_[3*I+2],P=Math.sqrt(T*T+C*C),y+=P,o.push(y);let f=0,D=0;for(let I=0;I<g.length;I+=3)Math.abs(g[I+1])<.001&&(D=1),Math.abs(g[I+1]-1)<.001&&(D=0),Math.abs(g[I+1]+1)<.001&&(D=2),f=I/3,D===1?(O=f-A,O%4<1.5?v?u[2*f]=r[D].x+(r[D].z-r[D].x)*o[Math.floor(O/4)]/y:u[2*f]=r[D].x:v?u[2*f]=r[D].x+(r[D].z-r[D].x)*o[Math.floor(O/4)+1]/y:u[2*f]=r[D].z,O%2===0?u[2*f+1]=se.UseOpenGLOrientationForUV?1-r[D].w:r[D].w:u[2*f+1]=se.UseOpenGLOrientationForUV?1-r[D].y:r[D].y):(u[2*f]=(1-u[2*f])*r[D].x+u[2*f]*r[D].z,u[2*f+1]=(1-u[2*f+1])*r[D].y+u[2*f+1]*r[D].w,se.UseOpenGLOrientationForUV&&(u[2*f+1]=1-u[2*f+1])),c&&x.push(c[D].r,c[D].g,c[D].b,c[D].a);X._ComputeSides(e,_,i,g,u,a,h);const z=new X;if(z.indices=i,z.positions=_,z.normals=g,z.uvs=u,c){const I=e===X.DOUBLESIDE?x.concat(x):x;z.colors=I}return z}function Te(d,e,t=null,s=earcut){e.sideOrientation=m._GetDefaultSideOrientation(e.sideOrientation);const a=e.shape,h=e.holes||[],l=e.depth||0,r=e.smoothingThreshold||2,c=[];let x=[];for(let i=0;i<a.length;i++)c[i]=new te(a[i].x,a[i].z);const v=1e-8;c[0].equalsWithEpsilon(c[c.length-1],v)&&c.pop();const _=new Kt(d,c,t||ut.LastCreatedScene,s);for(let i=0;i<h.length;i++){x=[];for(let A=0;A<h[i].length;A++)x.push(new te(h[i][A].x,h[i][A].z));_.addHole(x)}const g=_.build(!1,l,r);return g._originalBuilderSideOrientation=e.sideOrientation,At(g,e.sideOrientation,e.faceUV,e.faceColors,e.frontUVs,e.backUVs,e.wrap).applyToMesh(g,e.updatable),g}function De(d,e,t=null,s=earcut){return Te(d,e,t,s)}const xs={ExtrudePolygon:De,CreatePolygon:Te};X.CreatePolygon=At;m.CreatePolygon=(d,e,t,s,a,h,l=earcut)=>Te(d,{shape:e,holes:s,updatable:a,sideOrientation:h},t,l);m.ExtrudePolygon=(d,e,t,s,a,h,l,r=earcut)=>De(d,{shape:e,holes:a,depth:t,updatable:h,sideOrientation:l},s,r);function Qe(d,e,t=null){const s=e.path,a=e.shape,h=e.scale||1,l=e.rotation||0,r=e.cap===0?0:e.cap||m.NO_CAP,c=e.updatable,x=m._GetDefaultSideOrientation(e.sideOrientation),v=e.instance||null,_=e.invertUV||!1,g=e.closeShape||!1,u=e.closePath||!1;return _t(d,a,s,h,l,null,null,u,g,r,!1,t,!!c,x,v,_,e.frontUVs||null,e.backUVs||null,e.firstNormal||null,!!e.adjustFrame)}function Je(d,e,t=null){const s=e.path,a=e.shape,h=e.scaleFunction||(()=>1),l=e.rotationFunction||(()=>0),r=e.closePath||e.ribbonCloseArray||!1,c=e.closeShape||e.ribbonClosePath||!1,x=e.cap===0?0:e.cap||m.NO_CAP,v=e.updatable,_=e.firstNormal||null,g=e.adjustFrame||!1,u=m._GetDefaultSideOrientation(e.sideOrientation),i=e.instance,A=e.invertUV||!1;return _t(d,a,s,null,null,h,l,r,c,x,!0,t,!!v,u,i||null,A,e.frontUVs||null,e.backUVs||null,_,g)}function _t(d,e,t,s,a,h,l,r,c,x,v,_,g,u,i,A,O,T,C,P){const y=(I,F,b,V,K,Y,G,W,j,q,B)=>{const w=b.getTangents(),n=b.getNormals(),p=b.getBinormals(),L=b.getDistances();if(B){for(let N=0;N<w.length;N++)if(w[N].x==0&&w[N].y==0&&w[N].z==0&&w[N].copyFrom(w[N-1]),n[N].x==0&&n[N].y==0&&n[N].z==0&&n[N].copyFrom(n[N-1]),p[N].x==0&&p[N].y==0&&p[N].z==0&&p[N].copyFrom(p[N-1]),N>0){let ne=w[N-1];E.Dot(ne,w[N])<0&&w[N].scaleInPlace(-1),ne=n[N-1],E.Dot(ne,n[N])<0&&n[N].scaleInPlace(-1),ne=p[N-1],E.Dot(ne,p[N])<0&&p[N].scaleInPlace(-1)}}let M=0;const Q=()=>K!==null?K:1,R=q&&W?W:()=>Y!==null?Y:0,S=q&&G?G:Q;let H=j===m.NO_CAP||j===m.CAP_END?0:2;const U=pe.Matrix[0];for(let N=0;N<F.length;N++){const ne=new Array,le=R(N,L[N]),oe=S(N,L[N]);ce.RotationAxisToRef(w[N],M,U);for(let re=0;re<I.length;re++){const fe=w[N].scale(I[re].z).add(n[N].scale(I[re].x)).add(p[N].scale(I[re].y)),he=E.Zero();E.TransformCoordinatesToRef(fe,U,he),he.scaleInPlace(oe).addInPlace(F[N]),ne[re]=he}V[H]=ne,M+=le,H++}const Z=N=>{const ne=Array(),le=E.Zero();let oe;for(oe=0;oe<N.length;oe++)le.addInPlace(N[oe]);for(le.scaleInPlace(1/N.length),oe=0;oe<N.length;oe++)ne.push(le);return ne};switch(j){case m.NO_CAP:break;case m.CAP_START:V[0]=Z(V[2]),V[1]=V[2];break;case m.CAP_END:V[H]=V[H-1],V[H+1]=Z(V[H-1]);break;case m.CAP_ALL:V[0]=Z(V[2]),V[1]=V[2],V[H]=V[H-1],V[H+1]=Z(V[H-1]);break}return V};let o,f;if(i){const I=i._creationDataStorage;return o=C?I.path3D.update(t,C):I.path3D.update(t),f=y(e,t,I.path3D,I.pathArray,s,a,h,l,I.cap,v,P),i=xe("",{pathArray:f,closeArray:!1,closePath:!1,offset:0,updatable:!1,sideOrientation:0,instance:i},_||void 0),i}o=C?new ke(t,C):new ke(t);const D=new Array;x=x<0||x>3?0:x,f=y(e,t,o,D,s,a,h,l,x,v,P);const z=xe(d,{pathArray:f,closeArray:r,closePath:c,updatable:g,sideOrientation:u,invertUV:A,frontUVs:O||void 0,backUVs:T||void 0},_);return z._creationDataStorage.pathArray=f,z._creationDataStorage.path3D=o,z._creationDataStorage.cap=x,z}const gs={ExtrudeShape:Qe,ExtrudeShapeCustom:Je};m.ExtrudeShape=(d,e,t,s,a,h,l=null,r,c,x)=>{const v={shape:e,path:t,scale:s,rotation:a,cap:h===0?0:h||m.NO_CAP,sideOrientation:c,instance:x,updatable:r};return Qe(d,v,l)};m.ExtrudeShapeCustom=(d,e,t,s,a,h,l,r,c,x,v,_)=>{const g={shape:e,path:t,scaleFunction:s,rotationFunction:a,ribbonCloseArray:h,ribbonClosePath:l,cap:r===0?0:r||m.NO_CAP,sideOrientation:v,instance:_,updatable:x};return Je(d,g,c)};function $e(d,e,t=null){const s=e.arc?e.arc<=0||e.arc>1?1:e.arc:1,a=e.closed===void 0?!0:e.closed,h=e.shape,l=e.radius||1,r=e.tessellation||64,c=e.clip||0,x=e.updatable,v=m._GetDefaultSideOrientation(e.sideOrientation),_=e.cap||m.NO_CAP,g=Math.PI*2,u=new Array,i=e.invertUV||!1;let A=0,O=0;const T=g/r*s;let C,P;for(A=0;A<=r-c;A++){for(P=[],(_==m.CAP_START||_==m.CAP_ALL)&&(P.push(new E(0,h[0].y,0)),P.push(new E(Math.cos(A*T)*h[0].x*l,h[0].y,Math.sin(A*T)*h[0].x*l))),O=0;O<h.length;O++)C=new E(Math.cos(A*T)*h[O].x*l,h[O].y,Math.sin(A*T)*h[O].x*l),P.push(C);(_==m.CAP_END||_==m.CAP_ALL)&&(P.push(new E(Math.cos(A*T)*h[h.length-1].x*l,h[h.length-1].y,Math.sin(A*T)*h[h.length-1].x*l)),P.push(new E(0,h[h.length-1].y,0))),u.push(P)}return xe(d,{pathArray:u,closeArray:a,sideOrientation:v,updatable:x,invertUV:i,frontUVs:e.frontUVs,backUVs:e.backUVs},t)}const ps={CreateLathe:$e};m.CreateLathe=(d,e,t,s,a,h,l)=>$e(d,{shape:e,radius:t,tessellation:s,sideOrientation:l,updatable:h},a);function et(d,e,t=null){const s=e.path;let a=e.instance,h=1;e.radius!==void 0?h=e.radius:a&&(h=a._creationDataStorage.radius);const l=e.tessellation||64,r=e.radiusFunction||null;let c=e.cap||m.NO_CAP;const x=e.invertUV||!1,v=e.updatable,_=m._GetDefaultSideOrientation(e.sideOrientation);e.arc=e.arc&&(e.arc<=0||e.arc>1)?1:e.arc||1;const g=(T,C,P,y,o,f,D,z)=>{const I=C.getTangents(),F=C.getNormals(),b=C.getDistances(),K=Math.PI*2/o*z,G=f||(()=>y);let W,j,q,B;const w=pe.Matrix[0];let n=D===m.NO_CAP||D===m.CAP_END?0:2;for(let L=0;L<T.length;L++){j=G(L,b[L]),W=Array(),q=F[L];for(let M=0;M<o;M++)ce.RotationAxisToRef(I[L],K*M,w),B=W[M]?W[M]:E.Zero(),E.TransformCoordinatesToRef(q,w,B),B.scaleInPlace(j).addInPlace(T[L]),W[M]=B;P[n]=W,n++}const p=(L,M)=>{const Q=Array();for(let k=0;k<L;k++)Q.push(T[M]);return Q};switch(D){case m.NO_CAP:break;case m.CAP_START:P[0]=p(o,0),P[1]=P[2].slice(0);break;case m.CAP_END:P[n]=P[n-1].slice(0),P[n+1]=p(o,T.length-1);break;case m.CAP_ALL:P[0]=p(o,0),P[1]=P[2].slice(0),P[n]=P[n-1].slice(0),P[n+1]=p(o,T.length-1);break}return P};let u,i;if(a){const T=a._creationDataStorage,C=e.arc||T.arc;return u=T.path3D.update(s),i=g(s,u,T.pathArray,h,T.tessellation,r,T.cap,C),a=xe("",{pathArray:i,instance:a}),T.path3D=u,T.pathArray=i,T.arc=C,T.radius=h,a}u=new ke(s);const A=new Array;c=c<0||c>3?0:c,i=g(s,u,A,h,l,r,c,e.arc);const O=xe(d,{pathArray:i,closePath:!0,closeArray:!1,updatable:v,sideOrientation:_,invertUV:x,frontUVs:e.frontUVs,backUVs:e.backUVs},t);return O._creationDataStorage.pathArray=i,O._creationDataStorage.path3D=u,O._creationDataStorage.tessellation=l,O._creationDataStorage.cap=c,O._creationDataStorage.arc=e.arc,O._creationDataStorage.radius=h,O}const ms={CreateTube:et};m.CreateTube=(d,e,t,s,a,h,l,r,c,x)=>et(d,{path:e,radius:t,tessellation:s,radiusFunction:a,arc:1,cap:h,updatable:r,sideOrientation:c,instance:x},l);function bt(d){const e=[];e[0]={vertex:[[0,0,1.732051],[1.632993,0,-.5773503],[-.8164966,1.414214,-.5773503],[-.8164966,-1.414214,-.5773503]],face:[[0,1,2],[0,2,3],[0,3,1],[1,3,2]]},e[1]={vertex:[[0,0,1.414214],[1.414214,0,0],[0,1.414214,0],[-1.414214,0,0],[0,-1.414214,0],[0,0,-1.414214]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,1],[1,4,5],[1,5,2],[2,5,3],[3,5,4]]},e[2]={vertex:[[0,0,1.070466],[.7136442,0,.7978784],[-.3568221,.618034,.7978784],[-.3568221,-.618034,.7978784],[.7978784,.618034,.3568221],[.7978784,-.618034,.3568221],[-.9341724,.381966,.3568221],[.1362939,1,.3568221],[.1362939,-1,.3568221],[-.9341724,-.381966,.3568221],[.9341724,.381966,-.3568221],[.9341724,-.381966,-.3568221],[-.7978784,.618034,-.3568221],[-.1362939,1,-.3568221],[-.1362939,-1,-.3568221],[-.7978784,-.618034,-.3568221],[.3568221,.618034,-.7978784],[.3568221,-.618034,-.7978784],[-.7136442,0,-.7978784],[0,0,-1.070466]],face:[[0,1,4,7,2],[0,2,6,9,3],[0,3,8,5,1],[1,5,11,10,4],[2,7,13,12,6],[3,9,15,14,8],[4,10,16,13,7],[5,8,14,17,11],[6,12,18,15,9],[10,11,17,19,16],[12,13,16,19,18],[14,15,18,19,17]]},e[3]={vertex:[[0,0,1.175571],[1.051462,0,.5257311],[.3249197,1,.5257311],[-.8506508,.618034,.5257311],[-.8506508,-.618034,.5257311],[.3249197,-1,.5257311],[.8506508,.618034,-.5257311],[.8506508,-.618034,-.5257311],[-.3249197,1,-.5257311],[-1.051462,0,-.5257311],[-.3249197,-1,-.5257311],[0,0,-1.175571]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,5,7],[1,7,6],[1,6,2],[2,6,8],[2,8,3],[3,8,9],[3,9,4],[4,9,10],[4,10,5],[5,10,7],[6,7,11],[6,11,8],[7,10,11],[8,11,9],[9,11,10]]},e[4]={vertex:[[0,0,1.070722],[.7148135,0,.7971752],[-.104682,.7071068,.7971752],[-.6841528,.2071068,.7971752],[-.104682,-.7071068,.7971752],[.6101315,.7071068,.5236279],[1.04156,.2071068,.1367736],[.6101315,-.7071068,.5236279],[-.3574067,1,.1367736],[-.7888348,-.5,.5236279],[-.9368776,.5,.1367736],[-.3574067,-1,.1367736],[.3574067,1,-.1367736],[.9368776,-.5,-.1367736],[.7888348,.5,-.5236279],[.3574067,-1,-.1367736],[-.6101315,.7071068,-.5236279],[-1.04156,-.2071068,-.1367736],[-.6101315,-.7071068,-.5236279],[.104682,.7071068,-.7971752],[.6841528,-.2071068,-.7971752],[.104682,-.7071068,-.7971752],[-.7148135,0,-.7971752],[0,0,-1.070722]],face:[[0,2,3],[1,6,5],[4,9,11],[7,15,13],[8,16,10],[12,14,19],[17,22,18],[20,21,23],[0,1,5,2],[0,3,9,4],[0,4,7,1],[1,7,13,6],[2,5,12,8],[2,8,10,3],[3,10,17,9],[4,11,15,7],[5,6,14,12],[6,13,20,14],[8,12,19,16],[9,17,18,11],[10,16,22,17],[11,18,21,15],[13,15,21,20],[14,20,23,19],[16,19,23,22],[18,22,23,21]]},e[5]={vertex:[[0,0,1.322876],[1.309307,0,.1889822],[-.9819805,.8660254,.1889822],[.1636634,-1.299038,.1889822],[.3273268,.8660254,-.9449112],[-.8183171,-.4330127,-.9449112]],face:[[0,3,1],[2,4,5],[0,1,4,2],[0,2,5,3],[1,3,5,4]]},e[6]={vertex:[[0,0,1.159953],[1.013464,0,.5642542],[-.3501431,.9510565,.5642542],[-.7715208,-.6571639,.5642542],[.6633206,.9510565,-.03144481],[.8682979,-.6571639,-.3996071],[-1.121664,.2938926,-.03144481],[-.2348831,-1.063314,-.3996071],[.5181548,.2938926,-.9953061],[-.5850262,-.112257,-.9953061]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,9,7],[5,7,9,8],[0,3,7,5,1],[2,4,8,9,6]]},e[7]={vertex:[[0,0,1.118034],[.8944272,0,.6708204],[-.2236068,.8660254,.6708204],[-.7826238,-.4330127,.6708204],[.6708204,.8660254,.2236068],[1.006231,-.4330127,-.2236068],[-1.006231,.4330127,.2236068],[-.6708204,-.8660254,-.2236068],[.7826238,.4330127,-.6708204],[.2236068,-.8660254,-.6708204],[-.8944272,0,-.6708204],[0,0,-1.118034]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,10,7],[5,9,11,8],[7,10,11,9],[0,3,7,9,5,1],[2,4,8,11,10,6]]},e[8]={vertex:[[-.729665,.670121,.319155],[-.655235,-.29213,-.754096],[-.093922,-.607123,.537818],[.702196,.595691,.485187],[.776626,-.36656,-.588064]],face:[[1,4,2],[0,1,2],[3,0,2],[4,3,2],[4,1,0,3]]},e[9]={vertex:[[-.868849,-.100041,.61257],[-.329458,.976099,.28078],[-.26629,-.013796,-.477654],[-.13392,-1.034115,.229829],[.738834,.707117,-.307018],[.859683,-.535264,-.338508]],face:[[3,0,2],[5,3,2],[4,5,2],[1,4,2],[0,1,2],[0,3,5,4,1]]},e[10]={vertex:[[-.610389,.243975,.531213],[-.187812,-.48795,-.664016],[-.187812,.9759,-.664016],[.187812,-.9759,.664016],[.798201,.243975,.132803]],face:[[1,3,0],[3,4,0],[3,1,4],[0,2,1],[0,4,2],[2,4,1]]},e[11]={vertex:[[-1.028778,.392027,-.048786],[-.640503,-.646161,.621837],[-.125162,-.395663,-.540059],[.004683,.888447,-.651988],[.125161,.395663,.540059],[.632925,-.791376,.433102],[1.031672,.157063,-.354165]],face:[[3,2,0],[2,1,0],[2,5,1],[0,4,3],[0,1,4],[4,1,5],[2,3,6],[3,4,6],[5,2,6],[4,5,6]]},e[12]={vertex:[[-.669867,.334933,-.529576],[-.669867,.334933,.529577],[-.4043,1.212901,0],[-.334933,-.669867,-.529576],[-.334933,-.669867,.529577],[.334933,.669867,-.529576],[.334933,.669867,.529577],[.4043,-1.212901,0],[.669867,-.334933,-.529576],[.669867,-.334933,.529577]],face:[[8,9,7],[6,5,2],[3,8,7],[5,0,2],[4,3,7],[0,1,2],[9,4,7],[1,6,2],[9,8,5,6],[8,3,0,5],[3,4,1,0],[4,9,6,1]]},e[13]={vertex:[[-.931836,.219976,-.264632],[-.636706,.318353,.692816],[-.613483,-.735083,-.264632],[-.326545,.979634,0],[-.318353,-.636706,.692816],[-.159176,.477529,-.856368],[.159176,-.477529,-.856368],[.318353,.636706,.692816],[.326545,-.979634,0],[.613482,.735082,-.264632],[.636706,-.318353,.692816],[.931835,-.219977,-.264632]],face:[[11,10,8],[7,9,3],[6,11,8],[9,5,3],[2,6,8],[5,0,3],[4,2,8],[0,1,3],[10,4,8],[1,7,3],[10,11,9,7],[11,6,5,9],[6,2,0,5],[2,4,1,0],[4,10,7,1]]},e[14]={vertex:[[-.93465,.300459,-.271185],[-.838689,-.260219,-.516017],[-.711319,.717591,.128359],[-.710334,-.156922,.080946],[-.599799,.556003,-.725148],[-.503838,-.004675,-.969981],[-.487004,.26021,.48049],[-.460089,-.750282,-.512622],[-.376468,.973135,-.325605],[-.331735,-.646985,.084342],[-.254001,.831847,.530001],[-.125239,-.494738,-.966586],[.029622,.027949,.730817],[.056536,-.982543,-.262295],[.08085,1.087391,.076037],[.125583,-.532729,.485984],[.262625,.599586,.780328],[.391387,-.726999,-.716259],[.513854,-.868287,.139347],[.597475,.85513,.326364],[.641224,.109523,.783723],[.737185,-.451155,.538891],[.848705,-.612742,-.314616],[.976075,.365067,.32976],[1.072036,-.19561,.084927]],face:[[15,18,21],[12,20,16],[6,10,2],[3,0,1],[9,7,13],[2,8,4,0],[0,4,5,1],[1,5,11,7],[7,11,17,13],[13,17,22,18],[18,22,24,21],[21,24,23,20],[20,23,19,16],[16,19,14,10],[10,14,8,2],[15,9,13,18],[12,15,21,20],[6,12,16,10],[3,6,2,0],[9,3,1,7],[9,15,12,6,3],[22,17,11,5,4,8,14,19,23,24]]};const t=d.type&&(d.type<0||d.type>=e.length)?0:d.type||0,s=d.size,a=d.sizeX||s||1,h=d.sizeY||s||1,l=d.sizeZ||s||1,r=d.custom||e[t],c=r.face.length,x=d.faceUV||new Array(c),v=d.faceColors,_=d.flat===void 0?!0:d.flat,g=d.sideOrientation===0?0:d.sideOrientation||X.DEFAULTSIDE,u=new Array,i=new Array,A=new Array,O=new Array,T=new Array;let C=0,P=0;const y=new Array;let o=0,f=0,D,z,I,F,b,V;if(_)for(f=0;f<c;f++)v&&v[f]===void 0&&(v[f]=new ye(1,1,1,1)),x&&x[f]===void 0&&(x[f]=new Ke(0,0,1,1));if(_)for(f=0;f<c;f++){const Y=r.face[f].length;for(I=2*Math.PI/Y,F=.5*Math.tan(I/2),b=.5,o=0;o<Y;o++)u.push(r.vertex[r.face[f][o]][0]*a,r.vertex[r.face[f][o]][1]*h,r.vertex[r.face[f][o]][2]*l),y.push(C),C++,D=x[f].x+(x[f].z-x[f].x)*(.5+F),z=x[f].y+(x[f].w-x[f].y)*(b-.5),O.push(D,se.UseOpenGLOrientationForUV?1-z:z),V=F*Math.cos(I)-b*Math.sin(I),b=F*Math.sin(I)+b*Math.cos(I),F=V,v&&T.push(v[f].r,v[f].g,v[f].b,v[f].a);for(o=0;o<Y-2;o++)i.push(y[0+P],y[o+2+P],y[o+1+P]);P+=Y}else{for(o=0;o<r.vertex.length;o++)u.push(r.vertex[o][0]*a,r.vertex[o][1]*h,r.vertex[o][2]*l),O.push(0,se.UseOpenGLOrientationForUV?1:0);for(f=0;f<c;f++)for(o=0;o<r.face[f].length-2;o++)i.push(r.face[f][0],r.face[f][o+2],r.face[f][o+1])}X.ComputeNormals(u,i,A),X._ComputeSides(g,u,i,A,O,d.frontUVs,d.backUVs);const K=new X;return K.positions=u,K.indices=i,K.normals=A,K.uvs=O,v&&_&&(K.colors=T),K}function we(d,e={},t=null){const s=new m(d,t);return e.sideOrientation=m._GetDefaultSideOrientation(e.sideOrientation),s._originalBuilderSideOrientation=e.sideOrientation,bt(e).applyToMesh(s,e.updatable),s}const Os={CreatePolyhedron:we};X.CreatePolyhedron=bt;m.CreatePolyhedron=(d,e,t)=>we(d,e,t);const Xt=new E(1,0,0),Ht=new E(-1,0,0),Yt=new E(0,1,0),jt=new E(0,-1,0),qt=new E(0,0,1),Qt=new E(0,0,-1);class Ie{constructor(e=E.Zero(),t=E.Up(),s=te.Zero(),a=0,h=0,l=null,r=null,c=null,x=null){this.position=e,this.normal=t,this.uv=s,this.vertexIdx=a,this.vertexIdxForBones=h,this.localPositionOverride=l,this.localNormalOverride=r,this.matrixIndicesOverride=c,this.matrixWeightsOverride=x}clone(){var e,t,s,a;return new Ie(this.position.clone(),this.normal.clone(),this.uv.clone(),this.vertexIdx,this.vertexIdxForBones,(e=this.localPositionOverride)===null||e===void 0?void 0:e.slice(),(t=this.localNormalOverride)===null||t===void 0?void 0:t.slice(),(s=this.matrixIndicesOverride)===null||s===void 0?void 0:s.slice(),(a=this.matrixWeightsOverride)===null||a===void 0?void 0:a.slice())}}function tt(d,e,t){var s,a,h,l;const r=!!e.skeleton,c=t.localMode||r,x=e.overrideMaterialSideOrientation!==null&&e.overrideMaterialSideOrientation!==void 0,v=e.getIndices(),_=r?e.getPositionData(!0,!0):e.getVerticesData($.PositionKind),g=r?e.getNormalsData(!0,!0):e.getVerticesData($.NormalKind),u=c?r?e.getVerticesData($.PositionKind):_:null,i=c?r?e.getVerticesData($.NormalKind):g:null,A=e.getVerticesData($.UVKind),O=r?e.getVerticesData($.MatricesIndicesKind):null,T=r?e.getVerticesData($.MatricesWeightsKind):null,C=r?e.getVerticesData($.MatricesIndicesExtraKind):null,P=r?e.getVerticesData($.MatricesWeightsExtraKind):null,y=t.position||E.Zero();let o=t.normal||E.Up();const f=t.size||E.One(),D=t.angle||0;if(!o){const n=new E(0,0,1),p=e.getScene().activeCamera,L=E.TransformCoordinates(n,p.getWorldMatrix());o=p.globalPosition.subtract(L)}const z=-Math.atan2(o.z,o.x)-Math.PI/2,I=Math.sqrt(o.x*o.x+o.z*o.z),F=Math.atan2(o.y,I),b=new X;b.indices=[],b.positions=[],b.normals=[],b.uvs=[],b.matricesIndices=r?[]:null,b.matricesWeights=r?[]:null,b.matricesIndicesExtra=C?[]:null,b.matricesWeightsExtra=P?[]:null;let V=0;const K=(n,p)=>{const L=new Ie;if(!v||!_||!g)return L;const M=v[n];if(L.vertexIdx=M*3,L.vertexIdxForBones=M*4,L.position=new E(_[M*3],_[M*3+1],_[M*3+2]),E.TransformCoordinatesToRef(L.position,p,L.position),L.normal=new E(g[M*3],g[M*3+1],g[M*3+2]),E.TransformNormalToRef(L.normal,p,L.normal),t.captureUVS&&A){const Q=A[M*2+1];L.uv=new te(A[M*2],se.UseOpenGLOrientationForUV?1-Q:Q)}return L},Y=[0,0,0,0],G=(n,p)=>{if(n.length===0)return n;const L=.5*Math.abs(E.Dot(f,p)),M=(R,S,H,U)=>{for(let Z=0;Z<U;++Z)if(R[H+Z]===S)return H+Z;return-1},Q=(R,S)=>{var H,U,Z,N,ne,le,oe,re,fe,he,Pe,Ve,Be,Le,Ee,Re;const de=E.GetClipFactor(R.position,S.position,p,L);let Ae=Y,ie=Y;if(O&&T){const me=R.matrixIndicesOverride?0:R.vertexIdxForBones,Ne=(H=R.matrixIndicesOverride)!==null&&H!==void 0?H:O,ct=(U=R.matrixWeightsOverride)!==null&&U!==void 0?U:T,We=S.matrixIndicesOverride?0:S.vertexIdxForBones,lt=(Z=S.matrixIndicesOverride)!==null&&Z!==void 0?Z:O,ht=(N=S.matrixWeightsOverride)!==null&&N!==void 0?N:T;Ae=[0,0,0,0],ie=[0,0,0,0];let ge=0;for(let ue=0;ue<4;++ue)if(ct[me+ue]>0){const Oe=M(lt,Ne[me+ue],We,4);Ae[ge]=Ne[me+ue],ie[ge]=be.Lerp(ct[me+ue],Oe>=0?ht[Oe]:0,de),ge++}for(let ue=0;ue<4&&ge<4;++ue){const Oe=lt[We+ue];M(Ne,Oe,me,4)===-1&&(Ae[ge]=Oe,ie[ge]=be.Lerp(0,ht[We+ue],de),ge++)}const _e=ie[0]+ie[1]+ie[2]+ie[3];ie[0]/=_e,ie[1]/=_e,ie[2]/=_e,ie[3]/=_e}const st=R.localPositionOverride?R.localPositionOverride[0]:(ne=u==null?void 0:u[R.vertexIdx])!==null&&ne!==void 0?ne:0,nt=R.localPositionOverride?R.localPositionOverride[1]:(le=u==null?void 0:u[R.vertexIdx+1])!==null&&le!==void 0?le:0,at=R.localPositionOverride?R.localPositionOverride[2]:(oe=u==null?void 0:u[R.vertexIdx+2])!==null&&oe!==void 0?oe:0,Dt=S.localPositionOverride?S.localPositionOverride[0]:(re=u==null?void 0:u[S.vertexIdx])!==null&&re!==void 0?re:0,wt=S.localPositionOverride?S.localPositionOverride[1]:(fe=u==null?void 0:u[S.vertexIdx+1])!==null&&fe!==void 0?fe:0,Ft=S.localPositionOverride?S.localPositionOverride[2]:(he=u==null?void 0:u[S.vertexIdx+2])!==null&&he!==void 0?he:0,ot=R.localNormalOverride?R.localNormalOverride[0]:(Pe=i==null?void 0:i[R.vertexIdx])!==null&&Pe!==void 0?Pe:0,rt=R.localNormalOverride?R.localNormalOverride[1]:(Ve=i==null?void 0:i[R.vertexIdx+1])!==null&&Ve!==void 0?Ve:0,it=R.localNormalOverride?R.localNormalOverride[2]:(Be=i==null?void 0:i[R.vertexIdx+2])!==null&&Be!==void 0?Be:0,Ct=S.localNormalOverride?S.localNormalOverride[0]:(Le=i==null?void 0:i[S.vertexIdx])!==null&&Le!==void 0?Le:0,Pt=S.localNormalOverride?S.localNormalOverride[1]:(Ee=i==null?void 0:i[S.vertexIdx+1])!==null&&Ee!==void 0?Ee:0,Vt=S.localNormalOverride?S.localNormalOverride[2]:(Re=i==null?void 0:i[S.vertexIdx+2])!==null&&Re!==void 0?Re:0,ze=ot+(Ct-ot)*de,Me=rt+(Pt-rt)*de,Ue=it+(Vt-it)*de,Se=Math.sqrt(ze*ze+Me*Me+Ue*Ue);return new Ie(E.Lerp(R.position,S.position,de),E.Lerp(R.normal,S.normal,de).normalize(),te.Lerp(R.uv,S.uv,de),-1,-1,u?[st+(Dt-st)*de,nt+(wt-nt)*de,at+(Ft-at)*de]:null,i?[ze/Se,Me/Se,Ue/Se]:null,Ae,ie)};let k=null;n.length>3&&(k=new Array);for(let R=0;R<n.length;R+=3){let S=0,H=null,U=null,Z=null,N=null;const ne=E.Dot(n[R].position,p)-L,le=E.Dot(n[R+1].position,p)-L,oe=E.Dot(n[R+2].position,p)-L,re=ne>0,fe=le>0,he=oe>0;switch(S=(re?1:0)+(fe?1:0)+(he?1:0),S){case 0:n.length>3?(k.push(n[R]),k.push(n[R+1]),k.push(n[R+2])):k=n;break;case 1:if(k=k??new Array,re&&(H=n[R+1],U=n[R+2],Z=Q(n[R],H),N=Q(n[R],U)),fe){H=n[R],U=n[R+2],Z=Q(n[R+1],H),N=Q(n[R+1],U),k.push(Z),k.push(U.clone()),k.push(H.clone()),k.push(U.clone()),k.push(Z.clone()),k.push(N);break}he&&(H=n[R],U=n[R+1],Z=Q(n[R+2],H),N=Q(n[R+2],U)),H&&U&&Z&&N&&(k.push(H.clone()),k.push(U.clone()),k.push(Z),k.push(N),k.push(Z.clone()),k.push(U.clone()));break;case 2:k=k??new Array,re||(H=n[R].clone(),U=Q(H,n[R+1]),Z=Q(H,n[R+2]),k.push(H),k.push(U),k.push(Z)),fe||(H=n[R+1].clone(),U=Q(H,n[R+2]),Z=Q(H,n[R]),k.push(H),k.push(U),k.push(Z)),he||(H=n[R+2].clone(),U=Q(H,n[R]),Z=Q(H,n[R+1]),k.push(H),k.push(U),k.push(Z));break}}return k},W=e instanceof m?e:null,j=W==null?void 0:W._thinInstanceDataStorage.matrixData,q=(W==null?void 0:W.thinInstanceCount)||1,B=pe.Matrix[0];B.copyFrom(ce.IdentityReadOnly);for(let n=0;n<q;++n){if(W!=null&&W.hasThinInstances&&j){const R=n*16;B.setRowFromFloats(0,j[R+0],j[R+1],j[R+2],j[R+3]),B.setRowFromFloats(1,j[R+4],j[R+5],j[R+6],j[R+7]),B.setRowFromFloats(2,j[R+8],j[R+9],j[R+10],j[R+11]),B.setRowFromFloats(3,j[R+12],j[R+13],j[R+14],j[R+15])}const p=ce.RotationYawPitchRoll(z,F,D).multiply(ce.Translation(y.x,y.y,y.z)),L=ce.Invert(p),M=e.getWorldMatrix(),Q=B.multiply(M).multiply(L),k=new Array(3);for(let R=0;R<v.length;R+=3){let S=k;if(S[0]=K(R,Q),x&&c?(S[1]=K(R+2,Q),S[2]=K(R+1,Q)):(S[1]=K(R+1,Q),S[2]=K(R+2,Q)),!(t.cullBackFaces&&-S[0].normal.z<=0&&-S[1].normal.z<=0&&-S[2].normal.z<=0)&&(S=G(S,Xt),!!S&&(S=G(S,Ht),!!S&&(S=G(S,Yt),!!S&&(S=G(S,jt),!!S&&(S=G(S,qt),!!S&&(S=G(S,Qt),!!S)))))))for(let H=0;H<S.length;H++){const U=S[H];if(b.indices.push(V),c?(U.localPositionOverride?(b.positions[V*3]=U.localPositionOverride[0],b.positions[V*3+1]=U.localPositionOverride[1],b.positions[V*3+2]=U.localPositionOverride[2]):u&&(b.positions[V*3]=u[U.vertexIdx],b.positions[V*3+1]=u[U.vertexIdx+1],b.positions[V*3+2]=u[U.vertexIdx+2]),U.localNormalOverride?(b.normals[V*3]=U.localNormalOverride[0],b.normals[V*3+1]=U.localNormalOverride[1],b.normals[V*3+2]=U.localNormalOverride[2]):i&&(b.normals[V*3]=i[U.vertexIdx],b.normals[V*3+1]=i[U.vertexIdx+1],b.normals[V*3+2]=i[U.vertexIdx+2])):(U.position.toArray(b.positions,V*3),U.normal.toArray(b.normals,V*3)),b.matricesIndices&&b.matricesWeights&&(U.matrixIndicesOverride?(b.matricesIndices[V*4]=U.matrixIndicesOverride[0],b.matricesIndices[V*4+1]=U.matrixIndicesOverride[1],b.matricesIndices[V*4+2]=U.matrixIndicesOverride[2],b.matricesIndices[V*4+3]=U.matrixIndicesOverride[3]):(O&&(b.matricesIndices[V*4]=O[U.vertexIdxForBones],b.matricesIndices[V*4+1]=O[U.vertexIdxForBones+1],b.matricesIndices[V*4+2]=O[U.vertexIdxForBones+2],b.matricesIndices[V*4+3]=O[U.vertexIdxForBones+3]),C&&b.matricesIndicesExtra&&(b.matricesIndicesExtra[V*4]=C[U.vertexIdxForBones],b.matricesIndicesExtra[V*4+1]=C[U.vertexIdxForBones+1],b.matricesIndicesExtra[V*4+2]=C[U.vertexIdxForBones+2],b.matricesIndicesExtra[V*4+3]=C[U.vertexIdxForBones+3])),U.matrixWeightsOverride?(b.matricesWeights[V*4]=U.matrixWeightsOverride[0],b.matricesWeights[V*4+1]=U.matrixWeightsOverride[1],b.matricesWeights[V*4+2]=U.matrixWeightsOverride[2],b.matricesWeights[V*4+3]=U.matrixWeightsOverride[3]):(T&&(b.matricesWeights[V*4]=T[U.vertexIdxForBones],b.matricesWeights[V*4+1]=T[U.vertexIdxForBones+1],b.matricesWeights[V*4+2]=T[U.vertexIdxForBones+2],b.matricesWeights[V*4+3]=T[U.vertexIdxForBones+3]),P&&b.matricesWeightsExtra&&(b.matricesWeightsExtra[V*4]=P[U.vertexIdxForBones],b.matricesWeightsExtra[V*4+1]=P[U.vertexIdxForBones+1],b.matricesWeightsExtra[V*4+2]=P[U.vertexIdxForBones+2],b.matricesWeightsExtra[V*4+3]=P[U.vertexIdxForBones+3]))),t.captureUVS)U.uv.toArray(b.uvs,V*2);else{b.uvs.push(.5+U.position.x/f.x);const Z=.5+U.position.y/f.y;b.uvs.push(se.UseOpenGLOrientationForUV?1-Z:Z)}V++}}}b.indices.length===0&&(b.indices=null),b.positions.length===0&&(b.positions=null),b.normals.length===0&&(b.normals=null),b.uvs.length===0&&(b.uvs=null),((s=b.matricesIndices)===null||s===void 0?void 0:s.length)===0&&(b.matricesIndices=null),((a=b.matricesWeights)===null||a===void 0?void 0:a.length)===0&&(b.matricesWeights=null),((h=b.matricesIndicesExtra)===null||h===void 0?void 0:h.length)===0&&(b.matricesIndicesExtra=null),((l=b.matricesWeightsExtra)===null||l===void 0?void 0:l.length)===0&&(b.matricesWeightsExtra=null);const w=new m(d,e.getScene());return b.applyToMesh(w),c?(w.skeleton=e.skeleton,w.parent=e):(w.position=y.clone(),w.rotation=new E(F,z,D)),w.computeWorldMatrix(!0),w.refreshBoundingInfo(!0,!0),w}const vs={CreateDecal:tt};m.CreateDecal=(d,e,t,s,a,h)=>tt(d,e,{position:t,normal:s,size:a,angle:h});class J{constructor(e=0,t=0){this.x=e,this.y=t,e!==Math.floor(e)&&ae.Warn("x is not an integer, floor(x) used"),t!==Math.floor(t)&&ae.Warn("y is not an integer, floor(y) used")}clone(){return new J(this.x,this.y)}rotate60About(e){const t=this.x;return this.x=e.x+e.y-this.y,this.y=t+this.y-e.x,this}rotateNeg60About(e){const t=this.x;return this.x=t+this.y-e.y,this.y=e.x+e.y-t,this}rotate120(e,t){e!==Math.floor(e)&&ae.Warn("m not an integer only floor(m) used"),t!==Math.floor(t)&&ae.Warn("n not an integer only floor(n) used");const s=this.x;return this.x=e-s-this.y,this.y=t+s,this}rotateNeg120(e,t){e!==Math.floor(e)&&ae.Warn("m is not an integer, floor(m) used"),t!==Math.floor(t)&&ae.Warn("n is not an integer,   floor(n) used");const s=this.x;return this.x=this.y-t,this.y=e+t-s-this.y,this}toCartesianOrigin(e,t){const s=E.Zero();return s.x=e.x+2*this.x*t+this.y*t,s.y=e.y+Math.sqrt(3)*this.y*t,s}static Zero(){return new J(0,0)}}class It{constructor(){this.cartesian=[],this.vertices=[],this.max=[],this.min=[],this.closestTo=[],this.innerFacets=[],this.isoVecsABOB=[],this.isoVecsOBOA=[],this.isoVecsBAOA=[],this.vertexTypes=[],this.IDATA=new Ze("icosahedron","Regular",[[0,ee,-1],[-ee,1,0],[-1,0,-ee],[1,0,-ee],[ee,1,0],[0,ee,1],[-1,0,ee],[-ee,-1,0],[0,-ee,-1],[ee,-1,0],[1,0,ee],[0,-ee,1]],[[0,2,1],[0,3,2],[0,4,3],[0,5,4],[0,1,5],[7,6,1],[8,7,2],[9,8,3],[10,9,4],[6,10,5],[2,7,1],[3,8,2],[4,9,3],[5,10,4],[1,6,5],[11,6,7],[11,7,8],[11,8,9],[11,9,10],[11,10,6]])}setIndices(){let e=12;const t={},s=this.m,a=this.n;let h=s,l=1,r=0;a!==0&&(h=be.HCF(s,a)),l=s/h,r=a/h;let c,x,v,_,g;const u=J.Zero(),i=new J(s,a),A=new J(-a,s+a),O=J.Zero(),T=J.Zero(),C=J.Zero();let P=[],y,o,f,D;const z=[],I=this.vertByDist,F=(b,V,K,Y)=>{y=b+"|"+K,o=V+"|"+Y,y in t||o in t?y in t&&!(o in t)?t[o]=t[y]:o in t&&!(y in t)&&(t[y]=t[o]):(t[y]=e,t[o]=e,e++),I[K][0]>2?z[t[y]]=[-I[K][0],I[K][1],t[y]]:z[t[y]]=[P[I[K][0]],I[K][1],t[y]]};this.IDATA.edgematch=[[1,"B"],[2,"B"],[3,"B"],[4,"B"],[0,"B"],[10,"O",14,"A"],[11,"O",10,"A"],[12,"O",11,"A"],[13,"O",12,"A"],[14,"O",13,"A"],[0,"O"],[1,"O"],[2,"O"],[3,"O"],[4,"O"],[19,"B",5,"A"],[15,"B",6,"A"],[16,"B",7,"A"],[17,"B",8,"A"],[18,"B",9,"A"]];for(let b=0;b<20;b++){if(P=this.IDATA.face[b],v=P[2],_=P[1],g=P[0],f=u.x+"|"+u.y,y=b+"|"+f,y in t||(t[y]=v,z[v]=[P[I[f][0]],I[f][1]]),f=i.x+"|"+i.y,y=b+"|"+f,y in t||(t[y]=_,z[_]=[P[I[f][0]],I[f][1]]),f=A.x+"|"+A.y,y=b+"|"+f,y in t||(t[y]=g,z[g]=[P[I[f][0]],I[f][1]]),c=this.IDATA.edgematch[b][0],x=this.IDATA.edgematch[b][1],x==="B")for(let V=1;V<h;V++)T.x=s-V*(l+r),T.y=a+V*l,C.x=-V*r,C.y=V*(l+r),f=T.x+"|"+T.y,D=C.x+"|"+C.y,F(b,c,f,D);if(x==="O")for(let V=1;V<h;V++)C.x=-V*r,C.y=V*(l+r),O.x=V*l,O.y=V*r,f=C.x+"|"+C.y,D=O.x+"|"+O.y,F(b,c,f,D);if(c=this.IDATA.edgematch[b][2],x=this.IDATA.edgematch[b][3],x&&x==="A")for(let V=1;V<h;V++)O.x=V*l,O.y=V*r,T.x=s-(h-V)*(l+r),T.y=a+(h-V)*l,f=O.x+"|"+O.y,D=T.x+"|"+T.y,F(b,c,f,D);for(let V=0;V<this.vertices.length;V++)f=this.vertices[V].x+"|"+this.vertices[V].y,y=b+"|"+f,y in t||(t[y]=e++,I[f][0]>2?z[t[y]]=[-I[f][0],I[f][1],t[y]]:z[t[y]]=[P[I[f][0]],I[f][1],t[y]])}this.closestTo=z,this.vecToidx=t}calcCoeffs(){const e=this.m,t=this.n,s=Math.sqrt(3)/3,a=e*e+t*t+e*t;this.coau=(e+t)/a,this.cobu=-t/a,this.coav=-s*(e-t)/a,this.cobv=s*(2*e+t)/a}createInnerFacets(){const e=this.m,t=this.n;for(let s=0;s<t+e+1;s++)for(let a=this.min[s];a<this.max[s]+1;a++)a<this.max[s]&&a<this.max[s+1]+1&&this.innerFacets.push(["|"+a+"|"+s,"|"+a+"|"+(s+1),"|"+(a+1)+"|"+s]),s>0&&a<this.max[s-1]&&a+1<this.max[s]+1&&this.innerFacets.push(["|"+a+"|"+s,"|"+(a+1)+"|"+s,"|"+(a+1)+"|"+(s-1)])}edgeVecsABOB(){const e=this.m,t=this.n,s=new J(-t,e+t);for(let a=1;a<e+t;a++){const h=new J(this.min[a],a),l=new J(this.min[a-1],a-1),r=new J(this.min[a+1],a+1),c=h.clone(),x=l.clone(),v=r.clone();c.rotate60About(s),x.rotate60About(s),v.rotate60About(s);const _=new J(this.max[c.y],c.y),g=new J(this.max[c.y-1],c.y-1),u=new J(this.max[c.y-1]-1,c.y-1);(c.x!==_.x||c.y!==_.y)&&(c.x!==g.x?(this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([h,g,u]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([h,u,_])):c.y===v.y?(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([h,l,g]),this.vertexTypes.push([1,0,1]),this.isoVecsABOB.push([h,g,r])):(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([h,l,g]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([h,g,_])))}}mapABOBtoOBOA(){const e=new J(0,0);for(let t=0;t<this.isoVecsABOB.length;t++){const s=[];for(let a=0;a<3;a++)e.x=this.isoVecsABOB[t][a].x,e.y=this.isoVecsABOB[t][a].y,this.vertexTypes[t][a]===0&&e.rotateNeg120(this.m,this.n),s.push(e.clone());this.isoVecsOBOA.push(s)}}mapABOBtoBAOA(){const e=new J(0,0);for(let t=0;t<this.isoVecsABOB.length;t++){const s=[];for(let a=0;a<3;a++)e.x=this.isoVecsABOB[t][a].x,e.y=this.isoVecsABOB[t][a].y,this.vertexTypes[t][a]===1&&e.rotate120(this.m,this.n),s.push(e.clone());this.isoVecsBAOA.push(s)}}MapToFace(e,t){const s=this.IDATA.face[e],a=s[2],h=s[1],l=s[0],r=E.FromArray(this.IDATA.vertex[a]),c=E.FromArray(this.IDATA.vertex[h]),x=E.FromArray(this.IDATA.vertex[l]),v=c.subtract(r),_=x.subtract(r),g=v.scale(this.coau).add(_.scale(this.cobu)),u=v.scale(this.coav).add(_.scale(this.cobv));let i,A=pe.Vector3[0];for(let O=0;O<this.cartesian.length;O++)A=g.scale(this.cartesian[O].x).add(u.scale(this.cartesian[O].y)).add(r),A.x,A.y,A.z,i=e+"|"+this.vertices[O].x+"|"+this.vertices[O].y,t.vertex[this.vecToidx[i]]=[A.x,A.y,A.z]}build(e,t){const s=new Array,a=J.Zero(),h=new J(e,t),l=new J(-t,e+t);s.push(a,h,l);for(let o=t;o<e+1;o++)for(let f=0;f<e+1-o;f++)s.push(new J(f,o));if(t>0){const o=be.HCF(e,t),f=e/o,D=t/o;for(let I=1;I<o;I++)s.push(new J(I*f,I*D)),s.push(new J(-I*D,I*(f+D))),s.push(new J(e-I*(f+D),t+I*f));const z=e/t;for(let I=1;I<t;I++)for(let F=0;F<I*z;F++)s.push(new J(F,I)),s.push(new J(F,I).rotate120(e,t)),s.push(new J(F,I).rotateNeg120(e,t))}s.sort((o,f)=>o.x-f.x),s.sort((o,f)=>o.y-f.y);const r=new Array(e+t+1),c=new Array(e+t+1);for(let o=0;o<r.length;o++)r[o]=1/0,c[o]=-1/0;let x=0,v=0;const _=s.length;for(let o=0;o<_;o++)v=s[o].x,x=s[o].y,r[x]=Math.min(v,r[x]),c[x]=Math.max(v,c[x]);const g=(o,f)=>{const D=o.clone();return f==="A"&&D.rotateNeg120(e,t),f==="B"&&D.rotate120(e,t),D.x<0?D.y:D.x+D.y},u=[],i=[],A=[],O=[],T={},C=[];let P=-1,y=-1;for(let o=0;o<_;o++)u[o]=s[o].toCartesianOrigin(new J(0,0),.5),i[o]=g(s[o],"O"),A[o]=g(s[o],"A"),O[o]=g(s[o],"B"),i[o]===A[o]&&A[o]===O[o]?(P=3,y=i[o]):i[o]===A[o]?(P=4,y=i[o]):A[o]===O[o]?(P=5,y=A[o]):O[o]===i[o]&&(P=6,y=i[o]),i[o]<A[o]&&i[o]<O[o]&&(P=2,y=i[o]),A[o]<i[o]&&A[o]<O[o]&&(P=1,y=A[o]),O[o]<A[o]&&O[o]<i[o]&&(P=0,y=O[o]),C.push([P,y,s[o].x,s[o].y]);C.sort((o,f)=>o[2]-f[2]),C.sort((o,f)=>o[3]-f[3]),C.sort((o,f)=>o[1]-f[1]),C.sort((o,f)=>o[0]-f[0]);for(let o=0;o<C.length;o++)T[C[o][2]+"|"+C[o][3]]=[C[o][0],C[o][1],o];return this.m=e,this.n=t,this.vertices=s,this.vertByDist=T,this.cartesian=u,this.min=r,this.max=c,this}}class Ze{constructor(e,t,s,a){this.name=e,this.category=t,this.vertex=s,this.face=a}}class Fe extends Ze{innerToData(e,t){for(let s=0;s<t.innerFacets.length;s++)this.face.push(t.innerFacets[s].map(a=>t.vecToidx[e+a]))}mapABOBtoDATA(e,t){const s=t.IDATA.edgematch[e][0];for(let a=0;a<t.isoVecsABOB.length;a++){const h=[];for(let l=0;l<3;l++)t.vertexTypes[a][l]===0?h.push(e+"|"+t.isoVecsABOB[a][l].x+"|"+t.isoVecsABOB[a][l].y):h.push(s+"|"+t.isoVecsABOB[a][l].x+"|"+t.isoVecsABOB[a][l].y);this.face.push([t.vecToidx[h[0]],t.vecToidx[h[1]],t.vecToidx[h[2]]])}}mapOBOAtoDATA(e,t){const s=t.IDATA.edgematch[e][0];for(let a=0;a<t.isoVecsOBOA.length;a++){const h=[];for(let l=0;l<3;l++)t.vertexTypes[a][l]===1?h.push(e+"|"+t.isoVecsOBOA[a][l].x+"|"+t.isoVecsOBOA[a][l].y):h.push(s+"|"+t.isoVecsOBOA[a][l].x+"|"+t.isoVecsOBOA[a][l].y);this.face.push([t.vecToidx[h[0]],t.vecToidx[h[1]],t.vecToidx[h[2]]])}}mapBAOAtoDATA(e,t){const s=t.IDATA.edgematch[e][2];for(let a=0;a<t.isoVecsBAOA.length;a++){const h=[];for(let l=0;l<3;l++)t.vertexTypes[a][l]===1?h.push(e+"|"+t.isoVecsBAOA[a][l].x+"|"+t.isoVecsBAOA[a][l].y):h.push(s+"|"+t.isoVecsBAOA[a][l].x+"|"+t.isoVecsBAOA[a][l].y);this.face.push([t.vecToidx[h[0]],t.vecToidx[h[1]],t.vecToidx[h[2]]])}}orderData(e){const t=[];for(let l=0;l<13;l++)t[l]=[];const s=e.closestTo;for(let l=0;l<s.length;l++)s[l][0]>-1?s[l][1]>0&&t[s[l][0]].push([l,s[l][1]]):t[12].push([l,s[l][0]]);const a=[];for(let l=0;l<12;l++)a[l]=l;let h=12;for(let l=0;l<12;l++){t[l].sort((r,c)=>r[1]-c[1]);for(let r=0;r<t[l].length;r++)a[t[l][r][0]]=h++}for(let l=0;l<t[12].length;l++)a[t[12][l][0]]=h++;for(let l=0;l<this.vertex.length;l++)this.vertex[l].push(a[l]);this.vertex.sort((l,r)=>l[3]-r[3]);for(let l=0;l<this.vertex.length;l++)this.vertex[l].pop();for(let l=0;l<this.face.length;l++)for(let r=0;r<this.face[l].length;r++)this.face[l][r]=a[this.face[l][r]];this.sharedNodes=t[12].length,this.poleNodes=this.vertex.length-this.sharedNodes}setOrder(e,t){const s=[],a=[];let h=t.pop();a.push(h);let l=this.face[h].indexOf(e);l=(l+2)%3;let r=this.face[h][l];s.push(r);let c=0;for(;t.length>0;)h=t[c],this.face[h].indexOf(r)>-1?(l=(this.face[h].indexOf(r)+1)%3,r=this.face[h][l],s.push(r),a.push(h),t.splice(c,1),c=0):c++;return this.adjacentFaces.push(s),a}toGoldbergPolyhedronData(){const e=new Ze("GeoDual","Goldberg",[],[]);e.name="GD dual";const t=this.vertex.length,s=new Array(t);for(let x=0;x<t;x++)s[x]=[];for(let x=0;x<this.face.length;x++)for(let v=0;v<3;v++)s[this.face[x][v]].push(x);let a=0,h=0,l=0,r=[],c=[];this.adjacentFaces=[];for(let x=0;x<s.length;x++)e.face[x]=this.setOrder(x,s[x].concat([])),s[x].forEach(v=>{a=0,h=0,l=0,r=this.face[v];for(let _=0;_<3;_++)c=this.vertex[r[_]],a+=c[0],h+=c[1],l+=c[2];e.vertex[v]=[a/3,h/3,l/3]});return e}static BuildGeodesicData(e){const t=new Fe("Geodesic-m-n","Geodesic",[[0,ee,-1],[-ee,1,0],[-1,0,-ee],[1,0,-ee],[ee,1,0],[0,ee,1],[-1,0,ee],[-ee,-1,0],[0,-ee,-1],[ee,-1,0],[1,0,ee],[0,-ee,1]],[]);e.setIndices(),e.calcCoeffs(),e.createInnerFacets(),e.edgeVecsABOB(),e.mapABOBtoOBOA(),e.mapABOBtoBAOA();for(let a=0;a<e.IDATA.face.length;a++)e.MapToFace(a,t),t.innerToData(a,e),e.IDATA.edgematch[a][1]==="B"&&t.mapABOBtoDATA(a,e),e.IDATA.edgematch[a][1]==="O"&&t.mapOBOAtoDATA(a,e),e.IDATA.edgematch[a][3]==="A"&&t.mapBAOAtoDATA(a,e);t.orderData(e);const s=1;return t.vertex=t.vertex.map(function(a){const h=a[0],l=a[1],r=a[2],c=Math.sqrt(h*h+l*l+r*r);return a[0]*=s/c,a[1]*=s/c,a[2]*=s/c,a}),t}}function Jt(d,e,t=null){let s=e.m||1;s!==Math.floor(s)&&ae.Warn("m not an integer only floor(m) used");let a=e.n||0;if(a!==Math.floor(a)&&ae.Warn("n not an integer only floor(n) used"),a>s){const x=a;a=s,s=x,ae.Warn("n > m therefore m and n swapped")}const h=new It;h.build(s,a);const r={custom:Fe.BuildGeodesicData(h),size:e.size,sizeX:e.sizeX,sizeY:e.sizeY,sizeZ:e.sizeZ,faceUV:e.faceUV,faceColors:e.faceColors,flat:e.flat,updatable:e.updatable,sideOrientation:e.sideOrientation,frontUVs:e.frontUVs,backUVs:e.backUVs};return we(d,r,t)}m._GoldbergMeshParser=(d,e)=>Ce.Parse(d,e);class Ce extends m{constructor(){super(...arguments),this.goldbergData={faceColors:[],faceCenters:[],faceZaxis:[],faceXaxis:[],faceYaxis:[],nbSharedFaces:0,nbUnsharedFaces:0,nbFaces:0,nbFacesAtPole:0,adjacentFaces:[]}}relatedGoldbergFace(e,t){return t===void 0?(e>this.goldbergData.nbUnsharedFaces-1&&(ae.Warn("Maximum number of unshared faces used"),e=this.goldbergData.nbUnsharedFaces-1),this.goldbergData.nbUnsharedFaces+e):(e>11&&(ae.Warn("Last pole used"),e=11),t>this.goldbergData.nbFacesAtPole-1&&(ae.Warn("Maximum number of faces at a pole used"),t=this.goldbergData.nbFacesAtPole-1),12+e*this.goldbergData.nbFacesAtPole+t)}_changeGoldbergFaceColors(e){for(let s=0;s<e.length;s++){const a=e[s][0],h=e[s][1],l=e[s][2];for(let r=a;r<h+1;r++)this.goldbergData.faceColors[r]=l}const t=[];for(let s=0;s<12;s++)for(let a=0;a<5;a++)t.push(this.goldbergData.faceColors[s].r,this.goldbergData.faceColors[s].g,this.goldbergData.faceColors[s].b,this.goldbergData.faceColors[s].a);for(let s=12;s<this.goldbergData.faceColors.length;s++)for(let a=0;a<6;a++)t.push(this.goldbergData.faceColors[s].r,this.goldbergData.faceColors[s].g,this.goldbergData.faceColors[s].b,this.goldbergData.faceColors[s].a);return t}setGoldbergFaceColors(e){const t=this._changeGoldbergFaceColors(e);this.setVerticesData($.ColorKind,t)}updateGoldbergFaceColors(e){const t=this._changeGoldbergFaceColors(e);this.updateVerticesData($.ColorKind,t)}_changeGoldbergFaceUVs(e){const t=this.getVerticesData($.UVKind);for(let s=0;s<e.length;s++){const a=e[s][0],h=e[s][1],l=e[s][2],r=e[s][3],c=e[s][4],x=[],v=[];let _,g;for(let u=0;u<5;u++)_=l.x+r*Math.cos(c+u*Math.PI/2.5),g=l.y+r*Math.sin(c+u*Math.PI/2.5),_<0&&(_=0),_>1&&(_=1),x.push(_,g);for(let u=0;u<6;u++)_=l.x+r*Math.cos(c+u*Math.PI/3),g=l.y+r*Math.sin(c+u*Math.PI/3),_<0&&(_=0),_>1&&(_=1),v.push(_,g);for(let u=a;u<Math.min(12,h+1);u++)for(let i=0;i<5;i++)t[10*u+2*i]=x[2*i],t[10*u+2*i+1]=x[2*i+1];for(let u=Math.max(12,a);u<h+1;u++)for(let i=0;i<6;i++)t[12*u-24+2*i]=v[2*i],t[12*u-23+2*i]=v[2*i+1]}return t}setGoldbergFaceUVs(e){const t=this._changeGoldbergFaceUVs(e);this.setVerticesData($.UVKind,t)}updateGoldbergFaceUVs(e){const t=this._changeGoldbergFaceUVs(e);this.updateVerticesData($.UVKind,t)}placeOnGoldbergFaceAt(e,t,s){const a=E.RotationFromAxis(this.goldbergData.faceXaxis[t],this.goldbergData.faceYaxis[t],this.goldbergData.faceZaxis[t]);e.rotation=a,e.position=this.goldbergData.faceCenters[t].add(this.goldbergData.faceXaxis[t].scale(s.x)).add(this.goldbergData.faceYaxis[t].scale(s.y)).add(this.goldbergData.faceZaxis[t].scale(s.z))}serialize(e){super.serialize(e),e.type="GoldbergMesh";const t={};if(t.adjacentFaces=this.goldbergData.adjacentFaces,t.nbSharedFaces=this.goldbergData.nbSharedFaces,t.nbUnsharedFaces=this.goldbergData.nbUnsharedFaces,t.nbFaces=this.goldbergData.nbFaces,t.nbFacesAtPole=this.goldbergData.nbFacesAtPole,this.goldbergData.faceColors){t.faceColors=[];for(const s of this.goldbergData.faceColors)t.faceColors.push(s.asArray())}if(this.goldbergData.faceCenters){t.faceCenters=[];for(const s of this.goldbergData.faceCenters)t.faceCenters.push(s.asArray())}if(this.goldbergData.faceZaxis){t.faceZaxis=[];for(const s of this.goldbergData.faceZaxis)t.faceZaxis.push(s.asArray())}if(this.goldbergData.faceYaxis){t.faceYaxis=[];for(const s of this.goldbergData.faceYaxis)t.faceYaxis.push(s.asArray())}if(this.goldbergData.faceXaxis){t.faceXaxis=[];for(const s of this.goldbergData.faceXaxis)t.faceXaxis.push(s.asArray())}e.goldbergData=t}static Parse(e,t){const s=e.goldbergData;s.faceColors=s.faceColors.map(h=>ye.FromArray(h)),s.faceCenters=s.faceCenters.map(h=>E.FromArray(h)),s.faceZaxis=s.faceZaxis.map(h=>E.FromArray(h)),s.faceXaxis=s.faceXaxis.map(h=>E.FromArray(h)),s.faceYaxis=s.faceYaxis.map(h=>E.FromArray(h));const a=new Ce(e.name,t);return a.goldbergData=s,a}}function $t(d,e){const t=d.size,s=d.sizeX||t||1,a=d.sizeY||t||1,h=d.sizeZ||t||1,l=d.sideOrientation===0?0:d.sideOrientation||X.DEFAULTSIDE,r=new Array,c=new Array,x=new Array,v=new Array;let _=1/0,g=-1/0,u=1/0,i=-1/0;for(let T=0;T<e.vertex.length;T++)_=Math.min(_,e.vertex[T][0]*s),g=Math.max(g,e.vertex[T][0]*s),u=Math.min(u,e.vertex[T][1]*a),i=Math.max(i,e.vertex[T][1]*a);let A=0;for(let T=0;T<e.face.length;T++){const C=e.face[T],P=E.FromArray(e.vertex[C[0]]),y=E.FromArray(e.vertex[C[2]]),o=E.FromArray(e.vertex[C[1]]),f=y.subtract(P),D=o.subtract(P),z=E.Cross(D,f).normalize();for(let I=0;I<C.length;I++){x.push(z.x,z.y,z.z);const F=e.vertex[C[I]];r.push(F[0]*s,F[1]*a,F[2]*h);const b=(F[1]*a-u)/(i-u);v.push((F[0]*s-_)/(g-_),se.UseOpenGLOrientationForUV?1-b:b)}for(let I=0;I<C.length-2;I++)c.push(A,A+I+2,A+I+1);A+=C.length}X._ComputeSides(l,r,c,x,v);const O=new X;return O.positions=r,O.indices=c,O.normals=x,O.uvs=v,O}function Tt(d,e,t=null){const s=e.size,a=e.sizeX||s||1,h=e.sizeY||s||1,l=e.sizeZ||s||1;let r=e.m||1;r!==Math.floor(r)&&ae.Warn("m not an integer only floor(m) used");let c=e.n||0;if(c!==Math.floor(c)&&ae.Warn("n not an integer only floor(n) used"),c>r){const i=c;c=r,r=i,ae.Warn("n > m therefore m and n swapped")}const x=new It;x.build(r,c);const v=Fe.BuildGeodesicData(x),_=v.toGoldbergPolyhedronData(),g=new Ce(d,t);e.sideOrientation=m._GetDefaultSideOrientation(e.sideOrientation),g._originalBuilderSideOrientation=e.sideOrientation,$t(e,_).applyToMesh(g,e.updatable),g.goldbergData.nbSharedFaces=v.sharedNodes,g.goldbergData.nbUnsharedFaces=v.poleNodes,g.goldbergData.adjacentFaces=v.adjacentFaces,g.goldbergData.nbFaces=g.goldbergData.nbSharedFaces+g.goldbergData.nbUnsharedFaces,g.goldbergData.nbFacesAtPole=(g.goldbergData.nbUnsharedFaces-12)/12;for(let i=0;i<v.vertex.length;i++)g.goldbergData.faceCenters.push(E.FromArray(v.vertex[i])),g.goldbergData.faceCenters[i].x*=a,g.goldbergData.faceCenters[i].y*=h,g.goldbergData.faceCenters[i].z*=l,g.goldbergData.faceColors.push(new ye(1,1,1,1));for(let i=0;i<_.face.length;i++){const A=_.face[i],O=E.FromArray(_.vertex[A[0]]),T=E.FromArray(_.vertex[A[2]]),C=E.FromArray(_.vertex[A[1]]),P=T.subtract(O),y=C.subtract(O),o=E.Cross(y,P).normalize(),f=E.Cross(y,o).normalize();g.goldbergData.faceXaxis.push(y.normalize()),g.goldbergData.faceYaxis.push(o),g.goldbergData.faceZaxis.push(f)}return g}m.CreateGoldberg=Tt;class es{constructor(e){this._paths=[],this._tempPaths=[],this._holes=[],this._resolution=e}moveTo(e,t){this._currentPath=new Xe(e,t),this._tempPaths.push(this._currentPath)}lineTo(e,t){this._currentPath.addLineTo(e,t)}quadraticCurveTo(e,t,s,a){this._currentPath.addQuadraticCurveTo(e,t,s,a,this._resolution)}bezierCurveTo(e,t,s,a,h,l){this._currentPath.addBezierCurveTo(e,t,s,a,h,l,this._resolution)}extractHoles(){for(const e of this._tempPaths)e.area()>0?this._holes.push(e):this._paths.push(e);if(!this._paths.length&&this._holes.length){const e=this._holes;this._holes=this._paths,this._paths=e}this._tempPaths.length=0}get paths(){return this._paths}get holes(){return this._holes}}function ts(d,e,t,s,a,h){const l=h.glyphs[d]||h.glyphs["?"];if(!l)return null;const r=new es(a);if(l.o){const c=l.o.split(" ");for(let x=0,v=c.length;x<v;)switch(c[x++]){case"m":{const g=parseInt(c[x++])*e+t,u=parseInt(c[x++])*e+s;r.moveTo(g,u);break}case"l":{const g=parseInt(c[x++])*e+t,u=parseInt(c[x++])*e+s;r.lineTo(g,u);break}case"q":{const g=parseInt(c[x++])*e+t,u=parseInt(c[x++])*e+s,i=parseInt(c[x++])*e+t,A=parseInt(c[x++])*e+s;r.quadraticCurveTo(i,A,g,u);break}case"b":{const g=parseInt(c[x++])*e+t,u=parseInt(c[x++])*e+s,i=parseInt(c[x++])*e+t,A=parseInt(c[x++])*e+s,O=parseInt(c[x++])*e+t,T=parseInt(c[x++])*e+s;r.bezierCurveTo(i,A,O,T,g,u);break}}}return r.extractHoles(),{offsetX:l.ha*e,shapePath:r}}function ss(d,e,t,s){const a=Array.from(d),h=e/s.resolution,l=(s.boundingBox.yMax-s.boundingBox.yMin+s.underlineThickness)*h,r=[];let c=0,x=0;for(let v=0;v<a.length;v++){const _=a[v];if(_===`
`)c=0,x-=l;else{const g=ts(_,h,c,x,t,s);g&&(c+=g.offsetX,r.push(g.shapePath))}}return r}function ns(d,e,t,s={size:50,resolution:8,depth:1},a=null,h=earcut){const l=ss(e,s.size||50,s.resolution||8,t),r=[];for(const x of l){if(!x.paths.length)continue;const v=x.holes.slice();for(const _ of x.paths){const g=[],u=[],i=_.getPoints();for(const T of i)u.push(new E(T.x,0,T.y));const A=v.slice();for(const T of A){const C=T.getPoints();let P=!1;for(const o of C)if(_.isPointInside(o)){P=!0;break}if(!P)continue;const y=[];for(const o of C)y.push(new E(o.x,0,o.y));g.push(y),v.splice(v.indexOf(T),1)}if(!g.length&&v.length)for(const T of v){const C=T.getPoints(),P=[];for(const y of C)P.push(new E(y.x,0,y.y));g.push(P)}const O=De(d,{shape:u,holes:g.length?g:void 0,depth:s.depth||1,sideOrientation:m._GetDefaultSideOrientation(s.sideOrientation||m.DOUBLESIDE)},a,h);r.push(O)}}const c=m.MergeMeshes(r,!0,!0);if(c){const x=c==null?void 0:c.getBoundingInfo();c.position.x=-(x==null?void 0:x.boundingBox.extendSizeWorld._x),c.position.y=-(x==null?void 0:x.boundingBox.extendSizeWorld._y),c.position.z=-(x==null?void 0:x.boundingBox.extendSizeWorld._z),c.name=d,c.rotation.x=-Math.PI/2,c.bakeCurrentTransformIntoVertices()}return c}const ys={CreateBox:Lt,CreateTiledBox:vt,CreateSphere:Et,CreateDisc:je,CreateIcoSphere:He,CreateRibbon:xe,CreateCylinder:Rt,CreateTorus:zt,CreateTorusKnot:qe,CreateLineSystem:Mt,CreateLines:Ut,CreateDashedLines:St,ExtrudeShape:Qe,ExtrudeShapeCustom:Je,CreateLathe:$e,CreateTiledPlane:mt,CreatePlane:Nt,CreateGround:Wt,CreateTiledGround:Gt,CreateGroundFromHeightMap:kt,CreatePolygon:Te,ExtrudePolygon:De,CreateTube:et,CreatePolyhedron:we,CreateGeodesic:Jt,CreateGoldberg:Tt,CreateDecal:tt,CreateCapsule:Ye,CreateText:ns};export{et as A,ls as B,Ye as C,vs as D,Je as E,De as F,Fe as G,Ce as H,rs as I,xs as J,Kt as K,ps as L,ys as M,Os as N,Ze as O,fs as P,hs as Q,cs as R,gs as S,ds as T,us as U,ms as V,It as _,we as a,je as b,Qe as c,ss as d,is as e,xt as f,tt as g,pt as h,Jt as i,Tt as j,$t as k,He as l,ft as m,$e as n,Te as o,At as p,bt as q,xe as r,gt as s,ns as t,vt as u,Ot as v,mt as w,ve as x,qe as y,yt as z};
